[
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "Hi folks !\nI am a R trainer and developer. Passionate about knowledge sharing and open source, I enjoy engaging with my peers and learners and contributing to a dynamic and collaborative community.\nI used to have a blog a few years ago, based on Hugo (in French only).\nI have decided to give a try to Quarto Websites. This new site aims at sharing my thoughts and knowledge about R, data science, epidemiology-related stuff.\nBesides videos and blog posts present on this website, you can find some of my contributions to open source projects on Github :\n\n{shinygouv} - Use the French Governmental Design System (DSFR) on you shiny apps‚Äù\n{lozen} - Github and Gitlab project management tools for devs and lead dev‚Äù\n{fusen} - Inflates a Rmarkdown file to magically create a package.‚Äù\n\nI hope you will enjoy reading my posts. Feel free to contact me if you have any questions !"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "blog",
    "section": "",
    "text": "Welcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nYohann Mansiaux\n\n\n\n\n\n\n\n\n\n\n\n\nHow Github Copilot and ChatGPT have changed my life as an R developer\n\n\n\n\n\n\nshiny\n\n\njavascript\n\n\n\n\n\n\n\n\n\nNov 9, 2024\n\n\nYohann Mansiaux\n\n\n\n\n\n\n\n\n\n\n\n\nVSCode for R users\n\n\n\n\n\n\ndev\n\n\nvscode\n\n\n\n\n\n\n\n\n\nNov 7, 2024\n\n\nYohann Mansiaux\n\n\n\n\n\n\n\n\n\n\n\n\nInclude a demo dataset in a R package (video tutorial)\n\n\n\n\n\n\ndevelopment\n\n\npackage\n\n\n\n\n\n\n\n\n\nNov 6, 2024\n\n\nYohann Mansiaux\n\n\n\n\n\n\n\n\n\n\n\n\nBeyond Functions: How to Enrich an R Package with Data\n\n\n\n\n\n\ndevelopment\n\n\npackage\n\n\n\n\n\n\n\n\n\nOct 14, 2024\n\n\nYohann Mansiaux\n\n\n\n\n\n\n\n\n\n\n\n\nBoost your shiny app with sparkling data visualizations: A deep dive into Chart.js JavaScript library\n\n\n\n\n\n\nshiny\n\n\njavascript\n\n\n\n\n\n\n\n\n\nSep 3, 2024\n\n\nYohann Mansiaux\n\n\n\n\n\n\n\n\n\n\n\n\nPimping your {shiny} app with a JavaScript library : an example using sweetalert2\n\n\n\n\n\n\nshiny\n\n\njavascript\n\n\n\n\n\n\n\n\n\nApr 30, 2024\n\n\nYohann Mansiaux\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "R trainer and developer üñ•Ô∏è\nData scientist üìä\nEpidemiology and life science lover ü¶†\nBadminton player üè∏"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Pimping your {shiny} app with a JavaScript library : an example using sweetalert2",
    "section": "",
    "text": "You think that some of the components of {shiny} are not very functional or downright austere? Are you looking to implement some feature in your app but it is not available in the {shiny} toolbox? Take a look at JavaScript!\nJavaScript is a very popular programming language that is often used to add features to web pages. With HTML and CSS, JavaScript is an essential language for web developers. The size of its user community means that if you are looking to implement a particular feature, there is a good chance that someone has already had the same need as you and has shared their code!\nAn other positive point (and essential for us in this case) : it is possible to integrate JavaScript libraries into a {shiny} application to add features that are not available by default. In addition to that, {golem} will help us to set everything up.\nNo more excuses to back down, let‚Äôs go ! üöÄ"
  },
  {
    "objectID": "posts/post-with-code/index.html#tldr",
    "href": "posts/post-with-code/index.html#tldr",
    "title": "Pimping your {shiny} app with a JavaScript library : an example using sweetalert2",
    "section": "TL;DR",
    "text": "TL;DR\n\nGoing further in {shiny} by integrating a JavaScript library is possible!\n\nWe take the example of sweetalert2, which allows to display alerts that are more visually appealing than the basic ones\n{golem} has several functions to make it easier for us to integrate JavaScript libraries into a {shiny} app\nThis example is rather simple. The integration of libraries is sometimes harder because the documentation might be scarse or the library might be more complex to use"
  },
  {
    "objectID": "posts/post-with-code/index.html#import-sweetalert2-into-a-shiny-app-created-with-golem",
    "href": "posts/post-with-code/index.html#import-sweetalert2-into-a-shiny-app-created-with-golem",
    "title": "Pimping your {shiny} app with a JavaScript library : an example using sweetalert2",
    "section": "Import sweetalert2 into a {shiny} app created with {golem}",
    "text": "Import sweetalert2 into a {shiny} app created with {golem}\n\nsweetalert2\n\nsweetalert2 is a JavaScript library that allows you to display alerts that are more visually appealing than the basic ones\nIt is very well documented\nIt is very popular (more than 16000 ‚Äústars‚Äù on GitHub at the time of publication of this article)\n\nLet‚Äôs take a look at the possibilities offered by sweetalert2: https://sweetalert2.github.io/\n\n\n\n\n\n\n\n\n\nIf you click on ‚ÄúShow normal alert‚Äù, you will see a classic alert while clicking on ‚ÄúShow success message‚Äù, you will see a sweetalert2 alert.\nThe first one has a rather austere design while the second one is more modern and more pleasant to the eye, it will probably offer a better user experience.\nFeel free to play with the different types of alerts offered by sweetalert2 to get an idea of what is possible with this library by visiting the examples section.\n\n\nAdd the necessary dependencies to the {shiny} app\nThe following sections assume that you have already created a {shiny} app with {golem}.\nIf this is not the case and you want to know more about {golem}, I invite you to consult the official documentation.\nTo add sweetalert2 to your {shiny} app, you will need to find a way to incorporate the files needed for its operation into your application.\nTwo solutions are available to you:\n\nUse a ‚ÄúCDN‚Äù (Content Delivery Network) to load the files from a third-party server. The CDN will be the equivalent of a CRAN for JavaScript libraries. Concretely, we will ask our application to point to the sources of sweetalert2, hosted on a remote server.\nDownload the files needed for its operation and integrate them directly into your application. If your application is intended to be used on a machine that is not connected to the Internet, you will inevitably have to go through this step.\n\nDon‚Äôt panic! We will see both methods\n\nWhere to find the elements I need?\nThe sweetalert2 documentation is very well done. You will find all the information you need to integrate the library into your application from the Download section.\nHowever, you will need to learn how to identify the elements you need to integrate sweetalert2 into your application.\nLooking for the CDN\nIn the ‚ÄúDownload & Install‚Äù section, you will find a link to the sweetalert2 CDN. This is the link that we will have to add to our application in order to use the library.\n\n\n\n\n\n\n\n\n\nWhen you click on the link, you will arrive on a page that looks like this:\n\n\n\n\n\n\n\n\n\nWhat we are interested in here is the link in the &lt;script&gt; tag and the link in the &lt;link&gt; tag. The link to the file with the .js extension corresponds to the sweetalert2 JavaScript file. The link to the file with the .css extension corresponds to the sweetalert2 styles file.\nCopy them and let‚Äôs go back to our app!\n\n\nMethod 1: Add dependencies to sweetalert2 via the CDN\nLet‚Äôs open the R/app_ui.R file of our application and add the two links we copied earlier to the body of the golem_add_external_resources() function.\ngolem_add_external_resources &lt;- function() {\n  add_resource_path(\n    \"www\",\n    app_sys(\"app/www\")\n  )\n\n  tags$head(\n    favicon(),\n    bundle_resources(\n      path = app_sys(\"app/www\"),\n      app_title = \"golemsweetalert\"\n    ),\n    # sweetalert2\n    tags$script(src = \"https://cdn.jsdelivr.net/npm/sweetalert2@11.10.7/dist/sweetalert2.all.min.js\"),\n    tags$link(href = \"https://cdn.jsdelivr.net/npm/sweetalert2@11.10.7/dist/sweetalert2.min.css\",\n              rel=\"stylesheet\")\n \n  )\n}\nWe find here a call to tags$script and a call to tags$link corresponding respectively to the &lt;script&gt; and &lt;link&gt; tags seen on the links provided by the CDN.\nWe copy-paste the elements being careful about the parameter names src, href and rel and remembering to separate them with commas. We are indeed moving from HTML code (where elements are separated by spaces) to R code.\n\n\nMethod 2: Add dependencies to sweetalert2 locally\nThe links identified earlier will also be useful to download the files needed to use sweetalert2.\nThe link to the JavaScript file will be passed to the golem::use_external_js_file() function while the link to the CSS file will be passed to the golem::use_external_css_file() function.\nTo keep a record of this, we will save the following commands in the dev/02_dev.R file in the ‚ÄúExternal resources‚Äù section.\ngolem::use_external_js_file(\"https://cdn.jsdelivr.net/npm/sweetalert2@11.10.7/dist/sweetalert2.all.min.js\")\ngolem::use_external_css_file(\"https://cdn.jsdelivr.net/npm/sweetalert2@11.10.7/dist/sweetalert2.min.css\")\nBoth files are now present in the inst/app/www folder of our application project.\n\n\n\n\n\n\n\n\n\nEverything is ok, we can continue our journey üëç.\n\n\n\nHow to know if sweetalert2 is correctly imported into my {shiny} app?\nTo check that sweetalert2 is correctly imported into our application, we open our browser and then the development console.\nBefore that, let‚Äôs launch our app with golem::run_dev()!\nNB: The following screenshots were taken with the Google Chrome browser.\nOn the window of our application, we right-click and select ‚ÄúInspect‚Äù. In the new window that opens, we choose the ‚ÄúConsole‚Äù tab and then type the command Swal.fire(\"Hello sweetalert2!\"). This console allows us to execute JavaScript code, which will be interpreted by our browser.\nIf everything went well, we should see a sweetalert2 alert appear! Otherwise, we might have an error message in red (which we will have to learn to decipher, as with an R console :-)).\n\n\n\n\n\n\n\n\n\nIt works! üéâ\n\nHow did I know I had to type Swal.fire(\" .... \")?\nThanks to the documentation! By going to the sweetalert2 page, we find many examples of using the library. In this case, to display an alert, you have to use the Swal.fire() function. As for learning a new R package, we see that documentation (when it exists ‚Ä¶) is of paramount importance for the handling of JavaScript libraries."
  },
  {
    "objectID": "posts/post-with-code/index.html#create-a-sweetalert2-alert-in-our-shiny-app",
    "href": "posts/post-with-code/index.html#create-a-sweetalert2-alert-in-our-shiny-app",
    "title": "Pimping your {shiny} app with a JavaScript library : an example using sweetalert2",
    "section": "Create a sweetalert2 alert in our {shiny} app",
    "text": "Create a sweetalert2 alert in our {shiny} app\nNow that we have imported sweetalert2 into our application and checked that the import went well, we are going to create a function that will allow us to call sweetalert2 from our application.\nWe are going to try to incorporate the ‚ÄúA title with a text under‚Äù alert into our application.\n\n\n\n\n\n\n\n\n\nThree elements can be set here: - The title of the alert - The text of the alert - The type of alert (success, error, warning, info, question) and its associated icon\n\n\n\n\n\n\n\n\n\nWe can easily imagine how to modify these elements directly in the JavaScript code but we don‚Äôt know yet how to create this alert via R code. Let‚Äôs go!\n\nCreate a JavaScript file to call sweetalert2\nIn order to call sweetalert2 from our application, we are going to create a JavaScript file in which we will write a function that will allow us to create an alert.\nLet‚Äôs create a inst/app/www/sweet_alert.js file in which we will paste the code to create the alert selected earlier. We could have created this file manually, but we will take advantage of the features offered by {golem} to do so.\nLet‚Äôs go to the dev/02_dev.R file! We add the following line in the ‚ÄúExternal Resources‚Äù section:\ngolem::add_js_handler(\"sweet_alert\")\nThe file name doesn‚Äôt matter, but it is important to respect the .js extension so that the file is correctly interpreted as JavaScript code. We could have also created subfolders if we had had many imports and files to manage. The only prerequisite is that everything is located in the inst/app/www directory.\nWe obtain a slightly strange skeleton, which will in fact be the skeleton of a JavaScript function, usable in our {shiny} application:\n$( document ).ready(function() {\n  Shiny.addCustomMessageHandler('fun', function(arg) {\n \n  })\n});\nWe are going to substitute the term 'fun' with the name of the function we want to call in our {shiny} application and add the code to create the sweetalert2 alert.\nWe therefore obtain the following code:\n$( document ).ready(function() {\n  Shiny.addCustomMessageHandler('alert_title_and_text_under', function(arg) {\n    Swal.fire({\n      title: \"The Internet?\",\n      text: \"That thing is still around?\",\n      icon: \"question\"\n    });\n  })\n});\nOur parameters ‚Äútitle‚Äù, ‚Äútext‚Äù and ‚Äúicon‚Äù are fixed, we need to find a way to make them vary according to the choices of the user. We can notice the existence of a ‚Äúarg‚Äù parameter in the Shiny.addCustomMessageHandler() function. It is this parameter that will allow us to transmit information to our JavaScript function.\nLet‚Äôs modify our code:\n$( document ).ready(function() {\n  Shiny.addCustomMessageHandler('alert_title_and_text_under', function(arg) {\n    Swal.fire({\n      title: arg.title,\n      text: arg.text,\n      icon: arg.icon\n    });\n  })\n});\nThe notation to use here will be arg.parameter_name to access the values transmitted by our {shiny} application. The notation with the ‚Äú.‚Äù is a JavaScript convention for accessing object properties. To make the parallel with R, it‚Äôs a bit like if we were doing arg$parameter_name.\nOur JavaScript code is ready! Let‚Äôs move back to the R side!\n\n\nWhat if we tested all this in our {shiny} app (FINALLY!)?\nWe are going to add a button in the R/app_ui.R file:\napp_ui &lt;- function(request) {\n  tagList(\n    # Leave this function for adding external resources\n    golem_add_external_resources(),\n    # Your application UI logic\n    fluidPage(\n      h1(\"golemsweetalert\"),\n      actionButton(inputId = \"show_alert\",\n                   label = \"Alert demo\")\n    )\n  )\n}\nOn the server side, we add an observeEvent() in the R/app_server.R file, which will call our JavaScript function to generate an alert when the user clicks on the ‚ÄúAlert demo‚Äù button.\nOnce more, {golem} will make our life easier! We will use the golem::invoke_js() function to call our JavaScript function.\nTwo parameters are passed to golem::invoke_js():\n\nthe first parameter corresponds to the name of the JavaScript function to call\nthe second parameter corresponds to a list of parameters, the JavaScript equivalent of our arg object which will be used to transmit the information necessary to create the sweetalert2 alert. The names used in the list here must correspond to the names used in the JavaScript function for the arg parameter (‚Äútitle‚Äù, ‚Äútext‚Äù and ‚Äúicon‚Äù).\n\napp_server &lt;- function(input, output, session) {\n  # Your application server logic\n  observeEvent(\n    input$show_alert,{\n      golem::invoke_js(\n        \"alert_title_and_text_under\",\n        list(\n          title = \"Title\",\n          text = \"Text\",\n          icon = \"success\"\n        ))\n    }\n  )\n}\nWe run a call to golem::run_dev() to see our application in action!\n\n\n\n\n\n\n\n\n\nCongratulations! üëè\nTo make everything more elegant, we can create an R function that will call golem::invoke_js().\n\n\nCreate an R function to call sweetalert2\nWe are going to go through {golem} to create our function. To do this, we will add the following line in the dev/02_dev.R file of our application:\ngolem::add_fct(\"create_alert_title_and_text_under\")\nWe obtain a R/fct_create_alert_title_and_text_under.R file in which we will be able to write our function, which will call the JavaScript code created in the previous step.\n#' create_alert_title_and_text_under\n#'\n#' @description Creates an alert with a title, a text and an icon\n#' @param title alert title\n#' @param text alert text\n#' @param icon alert icon\n#' @return side effect : creates an alert\n#'\n#' @noRd\ncreate_alert_title_and_text_under &lt;- function(\n    title = \"Title\",\n    text = \"Text\",\n    icon = \"success\"\n    ) {\n  golem::invoke_js(\n    \"alert_title_and_text_under\",\n    list(\n      title = title,\n      text = text,\n      icon = icon\n    )\n  )\n}\nLet‚Äôs modify both the R/app_ui.R and R/app_server.R files to be able to define the parameters of our alert through choices made by the user.\napp_ui &lt;- function(request) {\n  tagList(\n    # Leave this function for adding external resources\n    golem_add_external_resources(),\n    # Your application UI logic\n    fluidPage(\n      h1(\"golemsweetalert\"),\n      textInput(inputId = \"title\",\n                label = \"title\"),\n      textInput(inputId = \"text\",\n                label = \"text\"),\n      radioButtons(inputId = \"icon\",\n                   label = \"icon\",\n                   choices = c(\"warning\", \"error\", \"success\", \"info\", \"question\")),\n      actionButton(inputId = \"show_alert\",\n                   label = \"Alert demo\")\n    )\n  )\n}\nTo define the list of possible ‚Äúchoices‚Äù for the radioButtons, we took the possible values for the icon parameter of sweetalert2, as indicated in the official documentation: https://sweetalert2.github.io/#icon.\napp_server &lt;- function(input, output, session) {\n  # Your application server logic\n  observeEvent(\n    input$show_alert,{\n      create_alert_title_and_text_under(\n        title = input$title,\n        text = input$text,\n        icon = input$icon\n      )\n    }\n  )\n}\nLet‚Äôs finally call golem::run_dev()!\n\n\n\n\n\n\n\n\n\nBravo ! üëè"
  },
  {
    "objectID": "posts/post-with-code/index.html#and-a-more-complex-example",
    "href": "posts/post-with-code/index.html#and-a-more-complex-example",
    "title": "Pimping your {shiny} app with a JavaScript library : an example using sweetalert2",
    "section": "And a more complex example?",
    "text": "And a more complex example?\nFollowing the previous steps, it is relatively easy to add additional elements to an alert, such as an image or confirmation / cancellation buttons. A slightly deeper dive into the sweetalert2 documentation will help you understand how to add these elements.\nLet‚Äôs see what is possible to achieve:\n\n\n\n\n\n\n\n\n\nYou are curious to know more? Go to this project source code."
  },
  {
    "objectID": "posts/post-with-code/index.html#conclusion",
    "href": "posts/post-with-code/index.html#conclusion",
    "title": "Pimping your {shiny} app with a JavaScript library : an example using sweetalert2",
    "section": "Conclusion",
    "text": "Conclusion\n\nIntegrating JavaScript libraries into a {shiny} application is possible!\n{golem} makes it easier for us\nIt is quite easy when the library is well documented\nIt is important to read the documentation of the library you want to integrate (but this is also true in R!)\nThe browser inspector is a very useful tool to check that everything is going well\nTo integrate more complex libraries, minimal JavaScript skills will probably be required\n\nIf you want more examples of the use of sweetalert2, but also other JavaScript libraries (Grid.js and Chart.js), you can consult the mycomicslibrary application and take a look at its source code.\nThanks for reading this tutorial and have fun in the wonderful world of JavaScript! üöÄ"
  },
  {
    "objectID": "posts/chartJS/index.html",
    "href": "posts/chartJS/index.html",
    "title": "Boost your shiny app with sparkling data visualizations: A deep dive into Chart.js JavaScript library",
    "section": "",
    "text": "Let‚Äôs continue our exploration of integrating JavaScript code into a {shiny} application! We will show how to move beyond the classic graphs produced in base R or with {ggplot2} to explore the interactive dataviz production libraries of JavaScript, particularly the Chart.js library.\nIf you missed my first article on integrating JavaScript libraries into a {shiny} application I invite you to read it before diving into this one.\nCrucial concepts are covered and will not be repeated here. We particularly think about:"
  },
  {
    "objectID": "posts/chartJS/index.html#tldr",
    "href": "posts/chartJS/index.html#tldr",
    "title": "Boost your shiny app with sparkling data visualizations: A deep dive into Chart.js JavaScript library",
    "section": "TL;DR",
    "text": "TL;DR\n\nCreating interactive charts that go beyond the usual dataviz produced in R is possible by integrating a JavaScript library!\n\nWe use the example of Chart.js, a very popular JavaScript dataviz library\nSpecificities related to integrating Chart.js into a {shiny} application are addressed, including passing data from R to JavaScript and the differences in expected data formats.\nWe‚Äôll see how to make sure our JavaScript code is working properly by using the web browser‚Äôs console."
  },
  {
    "objectID": "posts/chartJS/index.html#importing-chart.js-into-a-shiny-app-created-with-golem",
    "href": "posts/chartJS/index.html#importing-chart.js-into-a-shiny-app-created-with-golem",
    "title": "Boost your shiny app with sparkling data visualizations: A deep dive into Chart.js JavaScript library",
    "section": "Importing Chart.js into a {shiny} app created with {golem}",
    "text": "Importing Chart.js into a {shiny} app created with {golem}\n\nChart.js is a JavaScript library that allows you to create many types of charts (bars, lines, radar, etc.) and customize them as you wish\nIt is very well documented\nIt is the most popular JavaScript dataviz library on GitHub (over 60,000 ‚Äústars‚Äù at the time of this article‚Äôs publication)\n\nTo get an overview of the possibilities offered by Chart.js, visit the official page: https://www.chartjs.org/docs/latest/samples/information.html\n\nAdd the dependencies to Chart.js in your {shiny} app\nThe following sections assume that you have already created a {shiny} app with {golem}.\nIf this is not the case and you want to learn more about {golem}, I invite you to consult the official documentation.\nTo add Chart.js to your {shiny} app, you will need to find a way to incorporate the necessary files for its operation into your application. As we saw in our previous article, two solutions are possible.\n\nUse a ‚ÄúCDN‚Äù (Content Delivery Network) to load the files from a third-party server.\nDownload the necessary files and integrate them directly into the application.\n\nWe will use the ‚ÄúCDN‚Äù method here.\nGo to the  ‚ÄúGetting Started‚Äù section of Chart.js documentation .\n\n\n\n\n\n\n\n\n\nWe retrieve the CDN URL and store this information for later use.\nAfter creating the skeleton of an application via {golem}, we will add the Chart.js dependency.\nLet‚Äôs open the R/app_ui.R file of our application and add the link we copied earlier into the body of the golem_add_external_resources() function.\ngolem_add_external_resources &lt;- function() {\n  add_resource_path(\n    \"www\",\n    app_sys(\"app/www\")\n  )\n  \n  tags$head(\n    favicon(),\n    bundle_resources(\n      path = app_sys(\"app/www\"),\n      app_title = \"chartJS\"\n    ),\n    # Add here other external resources\n    # for example, you can add shinyalert::useShinyalert()\n    # Chart.js\n    tags$script(src = \"https://cdn.jsdelivr.net/npm/chart.js\")\n  )\n}\n\n\nHow to know if Chart.js is properly imported ?\nThe  ‚ÄúGetting Started‚Äù section previously consulted to retrieve the CDN link indicates that it is necessary to incorporate the HTML &lt;canvas&gt; tag into our application to display a Chart.js chart. We add this element to the R/app_ui.R file of our application.\napp_ui &lt;- function(request) {\n  tagList(\n    # Leave this function for adding external resources\n    golem_add_external_resources(),\n    # Your application UI logic\n    fluidPage(\n      h1(\"golemchartjs\"),\n      tags$div(\n        tags$canvas(id=\"myChart\")\n      )\n    )\n  )\n}\nTo verify that Chart.js is properly imported into our application, we run our app with golem::run_dev(), and the rest will take place in the web browser.\nNB: The following screenshots were taken using the Google Chrome browser.\nIn the window of our application, right-click and then select ‚ÄúInspect‚Äù. In the new window that opens, choose the ‚ÄúConsole‚Äù tab and type the command to generate a Chart.js chart, as indicated once again in the  ‚ÄúGetting Started‚Äù section between the HTML script tags.\nThe code to copy and paste into the console is the following:\n  const ctx = document.getElementById('myChart');\n\n  new Chart(ctx, {\n    type: 'bar',\n    data: {\n      labels: ['Red', 'Blue', 'Yellow', 'Green', 'Purple', 'Orange'],\n      datasets: [{\n        label: '# of Votes',\n        data: [12, 19, 3, 5, 2, 3],\n        borderWidth: 1\n      }]\n    },\n    options: {\n      scales: {\n        y: {\n          beginAtZero: true\n        }\n      }\n    }\n  });\n\nThe chart from the demo page appears as expected! üéâ\nWe can move on! üòä\nThe application code for this step is available here: https://github.com/ymansiaux/golemchartjs/tree/step1"
  },
  {
    "objectID": "posts/chartJS/index.html#creating-a-bar-chart-with-chart.js",
    "href": "posts/chartJS/index.html#creating-a-bar-chart-with-chart.js",
    "title": "Boost your shiny app with sparkling data visualizations: A deep dive into Chart.js JavaScript library",
    "section": "Creating a Bar Chart with Chart.js",
    "text": "Creating a Bar Chart with Chart.js\nThe code used previously allowed us to verify that Chart.js was properly imported into our application. Now, we will see how to create a Chart.js chart from our {shiny} application. The goal is to produce bar charts for various datasets with customizable options based on user choices.\nLet‚Äôs revisit the code executed previously:\n  const ctx = document.getElementById('myChart');\n\n  new Chart(ctx, {\n    type: 'bar',\n    data: {\n      labels: ['Red', 'Blue', 'Yellow', 'Green', 'Purple', 'Orange'],\n      datasets: [{\n        label: '# of Votes',\n        data: [12, 19, 3, 5, 2, 3],\n        borderWidth: 1\n      }]\n    },\n    options: {\n      scales: {\n        y: {\n          beginAtZero: true\n        }\n      }\n    }\n  });\nWe could imagine passing the labels, label, data, and borderWidth elements as function parameters.\nLet‚Äôs go! üöÄ\n\nCreating a JavaScript code usable from R\nWe saw in our previous article that the way to call JavaScript code from R is to use a ‚ÄúJS handler‚Äù. To do this, go to the dev/02_dev.R file! We add the following line in the ‚ÄúExternal Resources‚Äù section:\ngolem::add_js_handler(\"barchartJS\")\nWe fill in the skeleton by indicating ‚ÄúbarchartJS‚Äù as the name of our handler and adding the JavaScript code we saw previously.\n$(document).ready(function () {\n  Shiny.addCustomMessageHandler(\"barchartJS\", function (arg) {\n    const ctx = document.getElementById(\"myChart\");\n\n    new Chart(ctx, {\n      type: \"bar\",\n      data: {\n        labels: [\"Red\", \"Blue\", \"Yellow\", \"Green\", \"Purple\", \"Orange\"],\n        datasets: [\n          {\n            label: \"# of Votes\",\n            data: [12, 19, 3, 5, 2, 3],\n            borderWidth: 1,\n          },\n        ],\n      },\n      options: {\n        scales: {\n          y: {\n            beginAtZero: true,\n          },\n        },\n      },\n    });\n  });\n});\nWe replace the labels, label, data, and borderWidth parameters, which are hardcoded here, with the future elements passed as arguments to our handler. The notation to use here will be arg.param_name to access the values passed by our {shiny} application. The . notation is a JavaScript convention for accessing properties of an object. To draw a parallel with R, it‚Äôs somewhat like using arg$param_name.\nAt the beginning of our handler, we add a call to the console.log() function to check the contents of the arg element from the JS console. This will allow us to verify that the elements passed from R are correctly transmitted to our handler.\n$( document ).ready(function() {\n  Shiny.addCustomMessageHandler('barchartJS', function(arg) {\n    console.log(arg);    \n    const ctx = document.getElementById('myChart');\n\n    new Chart(ctx, {\n      type: 'bar',\n      data: {\n        labels: arg.labels,\n        datasets: [{\n          label: arg.label,\n          data: arg.data,\n          borderWidth: arg.borderWidth\n        }]\n      },\n      options: {\n        scales: {\n          y: {\n            beginAtZero: true\n          }\n        }\n      }\n    }); \n  })\n});\nWe will add elements to the R/app_ui.R file to generate the parameters to be passed to our handler:\n\narg.labels will be a vector of 5 character strings, randomly chosen from the letters of the latin alphabet.\narg.label will be a character string, randomly chosen from the letters of the latin alphabet.\narg.data will be a vector of 5 integer numbers, randomly chosen between 1 and 100.\narg.borderWidth will be an integer, randomly chosen between 1 and 5.\n\nThe display of the chart will be triggered by clicking a ‚ÄúShow Barplot‚Äù button.\nHere is the content of our R/app_ui.R file:\napp_ui &lt;- function(request) {\n    tagList(\n        # Leave this function for adding external resources\n        golem_add_external_resources(),\n        # Your application UI logic\n        fluidPage(\n            h1(\"golemchartjs\"),\n            actionButton(\n                inputId = \"showbarplot\",\n                label = \"Show Barplot\"\n            ),\n            tags$div(\n                tags$canvas(id = \"myChart\")\n            )\n        )\n    )\n}\nAnd the content of the R/app_server.R file :\napp_server &lt;- function(input, output, session) {\n    observeEvent(input$showbarplot, {\n        app_labels &lt;- sample(letters, 5)\n        app_label &lt;- paste0(sample(letters, 10), collapse = \"\")\n        app_data &lt;- sample(1:100, 5)\n        app_borderWidth &lt;- sample(1:5, 1)\n\n        golem::invoke_js(\n            \"barchartJS\",\n            list(\n                labels = app_labels,\n                label = app_label,\n                data = app_data,\n                borderWidth = app_borderWidth\n            )\n        )\n    })\n}\nHere are the key points to remember:\n\nThe first parameter in the call to golem::invoke_js() is the name of the JavaScript handler.\nThe following parameters are the elements to be passed as arguments to our handler. They should be passed in a named list where the names correspond to the elements in the arg object of our handler.\n\nLet‚Äôs run our application with golem::run_dev() and verify that everything works as expected!\n\nCongratulations! üëè\nIn addition to the displayed chart, we can see that the JavaScript console in the browser correctly shows the content of the arg object, including its 4 sub-elements: labels, label, data, and borderWidth.\nAnd if you click the button again, what happens?\n\nThe chart does not update; it remains stuck on the first chart! üòÆ\nThe JavaScript console indicates that the arg object has indeed been updated, but the chart does not refresh. Additionally, an error message appears in the JavaScript console: ‚ÄúError: Canvas is already in use. Chart with ID ‚Äò0‚Äô must be destroyed before the canvas with ID ‚ÄòmyChart‚Äô can be reused.‚Äù\nLet‚Äôs try to understand what‚Äôs happening: in the R/app_ui.R file, we added a canvas element with the ID ‚ÄúmyChart‚Äù (with tags$canvas(id = \"myChart\")). This element is used to display the chart. When we click the ‚ÄúShow Barplot‚Äù button, a new chart is generated and displayed in this element. However, the previous chart is not destroyed, and the error message indicates that the ‚Äúcanvas‚Äù is already in use.\nThe application code for this step is available here: https://github.com/ymansiaux/golemchartjs/tree/step2\n\n\nWhy isn‚Äôt the chart updating?\nTo find the answer, we need to refer back to the Chart.js documentation. We can read in the  ‚Äú.destroy()‚Äù section that in order to reuse the HTML ‚Äúcanvas‚Äù element for displaying a new chart, it is necessary to destroy the previous chart.\nThere is also a command  ‚Äú.update()‚Äù for updating an existing chart. This method seems more appropriate here, as we are using the same type of chart, with only a few parameters changing. The .update() method allows updating an existing chart without having to destroy and recreate it, which will be less ‚Äúbrutal‚Äù visually (with a chart disappearing and then reappearing). However, the .destroy() method should be kept in mind for cases where we want to radically change the type of chart, for example.\nUpdating a chart implies that a chart has already been generated once. Therefore, we need to modify our JavaScript handler to account for this and find a way to detect the existence of a chart on our page. For this, we will refer again to the Chart.js documentation, particularly the getChart method: https://www.chartjs.org/docs/latest/developers/api.html#static-getchart-key.\nThe command to use is in the following form: const chart = Chart.getChart(\"canvas-id\");. According to the documentation, if the chart exists, the variable chart will contain the Chart.js object associated with the HTML ‚Äúcanvas‚Äù element. If the chart does not exist, the variable chart will be undefined.\nFor this command to work, we need to replace ‚Äúcanvas-id‚Äù with the ID of our ‚Äúcanvas‚Äù, which is ‚ÄúmyChart‚Äù here: const chart = Chart.getChart(\"myChart\");\nLet‚Äôs restart our application. We indeed find that the chart object is undefined as long as the chart has not been created, and it correctly reflects this status afterwards.\n\nWe can adapt our code as follows:\n\nIf chart is undefined, we create a new chart.\nIf chart is not undefined, we update the existing chart.\n\nWe adapt our handler by referring to the documentation for the .update() method: https://www.chartjs.org/docs/latest/developers/api.html#update-mode\n$(document).ready(function () {\n  Shiny.addCustomMessageHandler(\"barchartJS\", function (arg) {\n    console.log(arg);\n    const ctx = document.getElementById(\"myChart\");\n\n    const chart = Chart.getChart(\"myChart\");\n\n    if (chart == undefined) {\n      console.log(\"Creating a new chart\");\n      new Chart(ctx, {\n        type: \"bar\",\n        data: {\n          labels: arg.labels,\n          datasets: [\n            {\n              label: arg.label,\n              data: arg.data,\n              borderWidth: arg.borderWidth,\n            },\n          ],\n        },\n        options: {\n          scales: {\n            y: {\n              beginAtZero: true,\n            },\n          },\n        },\n      });\n    } else {\n      console.log(\"Updating an existing chart\");\n      chart.data.labels = arg.labels;\n      chart.data.datasets[0].label = arg.label;\n      chart.data.datasets[0].data = arg.data;\n      chart.data.datasets[0].borderWidth = arg.borderWidth;\n      chart.update();\n    }\n  });\n});\nThis example is a bit more complex than those seen so far:\n\nRetrieve the Chart.js object associated with the HTML ‚Äúcanvas‚Äù element using the method Chart.getChart(\"myChart\").\nCheck if this object is undefined: if it is, use the code that has been working until now to create a new chart.\nIf it is not undefined, overwrite the configuration elements you want to update and then use the .update() method. Note the specifics of handling configuration elements: chart.data.labels = arg.labels for the labels, chart.data.datasets[0].label = arg.label for the label, etc. Use . to access object properties, with each . allowing access to a deeper level of ‚Äúdepth‚Äù. It is also important to note that array indexing starts at 0 in JavaScript, not at 1 like in R.\n\nAfter all these efforts, let‚Äôs see if everything is back in order üòÑ!\n\nPhew, everything is OK this time! ü•≤\nWe‚Äôve touched on a more complex case of using a JavaScript library in a {shiny} application. It is crucial to understand the library‚Äôs functioning by delving into the depths of its documentation. Moreover, one of the advantages of using a very popular library is that you can often find help on  StackOverflow üòä (here is an example of using the .destroy() method).\nFeel free to go further in customizing your chart, such as changing the bar colors: https://www.chartjs.org/docs/latest/general/colors.html and https://www.chartjs.org/docs/latest/charts/bar.html.\nThe best way to learn is to try reproducing examples from the documentation.\nThe application code for this step is available here: https://github.com/ymansiaux/golemchartjs/tree/step3"
  },
  {
    "objectID": "posts/chartJS/index.html#creating-a-scatter-plot-with-chart.js",
    "href": "posts/chartJS/index.html#creating-a-scatter-plot-with-chart.js",
    "title": "Boost your shiny app with sparkling data visualizations: A deep dive into Chart.js JavaScript library",
    "section": "Creating a Scatter Plot with Chart.js",
    "text": "Creating a Scatter Plot with Chart.js\nWe will attempt to create a scatter plot with Chart.js. To develop our code, we will rely on the Chart.js documentation: https://www.chartjs.org/docs/latest/charts/scatter.html.\nAs before, our code will be stored in a JS handler. Therefore, we will add a new handler in the dev/02_dev.R file:\ngolem::add_js_handler(\"scatterplotJS\")\nThe documentation is slightly different from that provided for bar charts. We will need to adapt our handler accordingly. We identify an element config, which will include the type, data, and options elements we have already seen. There is also a data element containing datasets and labels.\nWe will fill in the skeleton of our handler with the JavaScript code from the Chart.js documentation. Initially, we will leave out the ‚Äúupdate‚Äù part.\n$(document).ready(function () {\n  Shiny.addCustomMessageHandler(\"scatterplotJS\", function (arg) {\n    const ctx = document.getElementById(\"myChart2\");\n\n    const data = {\n      datasets: [\n        {\n          label: \"Scatter Dataset\",\n          data: [\n            {\n              x: -10,\n              y: 0,\n            },\n            {\n              x: 0,\n              y: 10,\n            },\n            {\n              x: 10,\n              y: 5,\n            },\n            {\n              x: 0.5,\n              y: 5.5,\n            },\n          ],\n          backgroundColor: \"rgb(255, 99, 132)\",\n        },\n      ],\n    };\n\n    const config = {\n      type: \"scatter\",\n      data: data,\n      options: {\n        scales: {\n          x: {\n            type: \"linear\",\n            position: \"bottom\",\n          },\n        },\n      },\n    };\n    new Chart(ctx, config);\n  });\n});\nOur JS handler ‚ÄúscatterplotJS‚Äù is ready! We need to add the ‚Äúdiv‚Äù and ‚Äúcanvas‚Äù to the UI to display the generated chart. We need to modify the HTML ID of our ‚Äúcanvas‚Äù to avoid any conflict with the bar chart. It will be named ‚ÄúmyChart2‚Äù here.\nNote that there is a slightly different syntax compared to the code used for the bar chart, where the call to ‚Äúnew Chart‚Äù was made directly with the data and options elements. Here, we store these elements in data and config variables before passing them to new Chart.\nNext, we add the following to the R/app_ui.R file:\nh1(\"Scatterplot\"),\nactionButton(\n    inputId = \"showscatterplot\",\n    label = \"Show Scatterplot\"\n),\ntags$div(\n    tags$canvas(id = \"myChart2\")\n)\nWe add the following to the R/app_server.R file:\n  observeEvent(input$showscatterplot, {\n    golem::invoke_js(\n      \"scatterplotJS\",\n      list(\n      )\n    )\n  })\nOur handler does not use any elements passed from R. However, it is necessary to pass an empty list as an argument to ensure the proper functioning of golem::invoke_js().\nLet‚Äôs run your application with golem::run_dev() and verify that everything works as expected!\n\nThe chart from the documentation works! üéâ\nNow, let‚Äôs go further by passing our own data as input.\nThe application code for this step is available here: https://github.com/ymansiaux/golemchartjs/tree/step4\n\nAn example with the iris dataset\nWe will use the iris dataset to generate a scatter plot. We will pass as arguments to our JS handler the data from the Sepal.Length and Sepal.Width columns.\nAs with the bar chart, we will use elements passed from R through the arg object in JavaScript.\nWe modify the data object to include a legend title and, most importantly, the data. To observe the elements passed from R, we add a call to console.log().\nconsole.log(arg);\nconst data = {\n  datasets: [\n    {\n      label: arg.label,\n      data: arg.data,\n      backgroundColor: \"rgb(255, 99, 132)\",\n    },\n  ],\n};\nAs a reminder, in the example from the documentation, the data is passed in the form of an ‚Äúarray of dictionaries‚Äù. Each dictionary contains the keys x and y for the point coordinates.\ndata: [{\n    x: -10,\n    y: 0\n  }, {\n    x: 0,\n    y: 10\n  }, {\n    x: 10,\n    y: 5\n  }, {\n    x: 0.5,\n    y: 5.5\n}]\nLet‚Äôs try to pass the contents of the Sepal.Length and Sepal.Width columns via a list. We make the following modification in R/app_server.R:\nobserveEvent(input$showscatterplot, {\n    golem::invoke_js(\n        \"scatterplotJS\",\n        list(\n            label = \"My scatterplot\",\n            data = list(\n                x = iris$Sepal.Length,\n                y = iris$Sepal.Width\n            )\n        )\n    )\n})\nWe restart our application, and unfortunately, nothing shows up!\n\nThanks to the console.log() call in our handler, we can observe the content of the arg object in the JavaScript console of the browser. We notice that the data passed is not in the correct format. Here, we get an array of two elements, the first containing the values of Sepal.Length and the second containing the values of Sepal.Width, which is not the expected format.\nHere, we need to do some work on the R side to transform our data into the expected format.\nIf we display a JSON preview of the data we passed as input, indeed the rendering is incorrect.\n\njsonlite::toJSON(\n    list(\n        x = iris$Sepal.Length,\n        y = iris$Sepal.Width\n    )\n)\n\n\n\n{\"x\":[5.1,4.9,4.7,4.6,5,5.4,4.6,5,4.4,4.9],\"y\":[3.5,3,3.2,3.1,3.6,3.9,3.4,3.4,2.9,3.1]} \n\n\nFor manipulating lists, the {purrr} package is a top choice.\n\nnew_data &lt;- purrr::transpose(\n    list(\n        x = iris$Sepal.Length,\n        y = iris$Sepal.Width\n    )\n)\njsonlite::toJSON(\n    new_data,\n    auto_unbox = TRUE\n)\n\n\n\n[{\"x\":5.1,\"y\":3.5},{\"x\":4.9,\"y\":3},{\"x\":4.7,\"y\":3.2},{\"x\":4.6,\"y\":3.1},{\"x\":5,\"y\":3.6},{\"x\":5.4,\"y\":3.9},{\"x\":4.6,\"y\":3.4},{\"x\":5,\"y\":3.4},{\"x\":4.4,\"y\":2.9},{\"x\":4.9,\"y\":3.1}] \n\n\nThe rendering seems to be more in line with what is expected by Chart.js. Therefore, we will modify our code to pass the data in this manner.\nobserveEvent(input$showscatterplot, {\n    golem::invoke_js(\n        \"scatterplotJS\",\n        list(\n            label = \"My scatterplot\",\n            data = purrr::transpose(\n                list(\n                    x = iris$Sepal.Length,\n                    y = iris$Sepal.Width\n                )\n            )\n        )\n    )\n})\nLet‚Äôs observe the result:\n\nThis time it‚Äôs good! üòä We can see in the JavaScript console that the data has indeed been passed in the correct format.\nThe application code for this step is available here: https://github.com/ymansiaux/golemchartjs/tree/step5\n\n\nA Little Extra Polish\nOur chart still lacks titles for the axes! To find out how to do this, the documentation comes to our rescue once again: https://www.chartjs.org/docs/latest/axes/labelling.html#scale-title-configuration.\nWe need to add a title object to our existing scales object. Each axis, ‚Äúx‚Äù and ‚Äúy‚Äù, is an object within the scales object and can have a title along with its associated parameters (color, font, etc.).\nWe will add a title element to the x object within our scales object. Several parameters are customizable, and we will need to modify the text parameter to set the title for each axis and the display parameter to show them, as this parameter is set to false by default (note the different boolean notation between JavaScript and R: true/false VS TRUE/FALSE).\nThe documentation sometimes lacks examples, so we can also rely on StackOverflow: https://stackoverflow.com/questions/27910719/in-chart-js-set-chart-title-name-of-x-axis-and-y-axis. However, be careful with the version of Chart.js used, as parameters may vary.\nIn our JS handler, we will add an xAxisTitle parameter and a yAxisTitle parameter.\nconst config = {\n    type: 'scatter',\n    data: data,\n    options: {\n      scales: {\n        x: {\n          type: 'linear',\n          position: 'bottom',\n          title: {\n            display: true,\n            text: arg.xAxisTitle\n            }\n          },\n        y: {\n          title: {\n            display: true,\n            text: arg.yAxisTitle\n          }\n        }\n      }\n    }\n  };\nBe cautious once again about the syntax difference between JavaScript and R. Parameters are passed in the form display: true rather than display = TRUE, for example. Confusing : with = can easily occur and result in non-functional code.\nIn our R/app_server.R file, we will add the xAxisTitle and yAxisTitle elements to the list passed as an argument to our handler.\nobserveEvent(input$showscatterplot, {\n    golem::invoke_js(\n        \"scatterplotJS\",\n        list(\n            label = \"My scatterplot\",\n            data = purrr::transpose(\n                list(\n                    x = iris$Sepal.Length,\n                    y = iris$Sepal.Width\n                )\n            ),\n            xAxisTitle = \"Sepal Length\",\n            yAxisTitle = \"Sepal Width\"\n        )\n    )\n})\nAnd here‚Äôs the result in our application:\n\nThe application code for this step is available here: https://github.com/ymansiaux/golemchartjs/tree/step6\n\n\nGoing further with the scatter plot\nAdditional modifications can be made to enhance the chart:\n\nModify the title\nChange the fill color of the points and their border color\n\nHere are the resources used to produce the code that we will present shortly:\n\nTitle: https://www.chartjs.org/docs/latest/configuration/title.html\nThe title should be included in a plugins object, which in turn is included in the options object.\nPoint Colors: https://www.chartjs.org/docs/latest/charts/line.html#point-styles\nThe color of the points will be managed within the datasets object.\n\nWe will offer users the ability to set the chart title, its color, and the color of the points through shiny inputs (which will be a good way to revisit the ‚Äúupdate‚Äù-related issues üòâ).\nBelow is a preview of the chart created here (without functional ‚Äúupdate‚Äù for now):\n\nThe handler code has been completed to account for these new elements:\n$(document).ready(function () {\n  Shiny.addCustomMessageHandler(\"scatterplotJS\", function (arg) {\n    const ctx = document.getElementById(\"myChart2\");\n\n    console.log(arg);\n\n    const data = {\n      datasets: [\n        {\n          label: arg.label,\n          data: arg.data,\n          borderColor: arg.pointBorderColor,\n          backgroundColor: arg.pointBackGroundColor,\n        },\n      ],\n    };\n\n    const plugins = {\n      title: {\n        display: true,\n        text: arg.mainTitle,\n        color: arg.mainTitleColor,\n      },\n    };\n\n    const config = {\n      type: \"scatter\",\n      data: data,\n      options: {\n        plugins: plugins,\n        scales: {\n          x: {\n            type: \"linear\",\n            position: \"bottom\",\n            title: {\n              display: true,\n              text: arg.xAxisTitle,\n            },\n          },\n          y: {\n            title: {\n              display: true,\n              text: arg.yAxisTitle,\n            },\n          },\n        },\n      },\n    };\n    new Chart(ctx, config);\n  });\n});\nIn R/app_ui.R, elements have been added to allow the user to pass the necessary parameters:\nh1(\"Scatterplot\"),\ntextInput(\n    inputId = \"scatterplot_title\",\n    label = \"Scatterplot Title\",\n    value = \"ChartJS rocks !\"\n),\nselectInput(\n    inputId = \"title_color\",\n    label = \"Title Color\",\n    choices = c(\"brown\", \"orange\", \"purple\"),\n    selected = \"brown\"\n),\nselectInput(\n  inputId = \"points_background_color\",\n    label = \"Points Background Color\",\n    choices = c(\"red\", \"blue\", \"green\"),\n    selected = \"red\"\n),\nactionButton(\n  inputId = \"showscatterplot\",\n    label = \"Show Scatterplot\"\n),\ntags$div(\n    tags$canvas(id = \"myChart2\")\n)\nFinally, in R/app_server.R, we add the necessary elements to pass the parameters to our handler:\nobserveEvent(input$showscatterplot, {\n        golem::invoke_js(\n            \"scatterplotJS\",\n            list(\n                label = \"My scatterplot\",\n                data = purrr::transpose(\n                    list(\n                        x = iris$Sepal.Length,\n                        y = iris$Sepal.Width\n                    )\n                ),\n                xAxisTitle = \"Sepal Length\",\n                yAxisTitle = \"Sepal Width\",\n                mainTitle = input$scatterplot_title,\n                mainTitleColor = input$title_color,\n                pointBorderColor = \"black\",\n                pointBackGroundColor = input$points_background_color\n            )\n        )\n    })\nThe application code for this step is available here: https://github.com/ymansiaux/golemchartjs/tree/step7\nWe still need to include the .update() method to account for updates to shiny inputs related to the title and the color of the points.\nWe will use the approach from the previous chart to modify our JS handler accordingly.\n$(document).ready(function () {\n  Shiny.addCustomMessageHandler(\"scatterplotJS\", function (arg) {\n    const ctx = document.getElementById(\"myChart2\");\n\n    console.log(arg);\n\n    const chart2 = Chart.getChart(\"myChart2\");\n\n    if (chart2 == undefined) {\n      console.log(\"Creating a new chart\");\n\n      const data = {\n        datasets: [\n          {\n            label: arg.label,\n            data: arg.data,\n            borderColor: arg.pointBorderColor,\n            backgroundColor: arg.pointBackGroundColor,\n          },\n        ],\n      };\n\n      const plugins = {\n        title: {\n          display: true,\n          text: arg.mainTitle,\n          color: arg.mainTitleColor,\n        },\n      };\n\n      const config = {\n        type: \"scatter\",\n        data: data,\n        options: {\n          plugins: plugins,\n          scales: {\n            x: {\n              type: \"linear\",\n              position: \"bottom\",\n              title: {\n                display: true,\n                text: arg.xAxisTitle,\n              },\n            },\n            y: {\n              title: {\n                display: true,\n                text: arg.yAxisTitle,\n              },\n            },\n          },\n        },\n      };\n      new Chart(ctx, config);\n    } else {\n      console.log(\"Updating an existing chart\");\n      chart2.data.datasets[0].backgroundColor = arg.pointBackGroundColor;\n      chart2.options.plugins.title.text = arg.mainTitle;\n      chart2.options.plugins.title.color = arg.mainTitleColor;\n      chart2.update();\n    }\n  });\n});\nLet‚Äôs observe the result:\n\nWell done! üéâ\nThe application code for this step is available here: https://github.com/ymansiaux/golemchartjs/tree/step8\n\n\nModifying the tooltip (advanced level)\nWe will look to modify the tooltip that appears when hovering over a point on the chart. In addition to changing its title, we want to display the row number from the dataset corresponding to the hovered point, as well as the corresponding values of Sepal.Length and Sepal.Width.\nHere are the resources used:\n\nTooltip title: https://www.chartjs.org/docs/latest/configuration/tooltip.html#tooltip-callbacks\nTooltip content: https://www.chartjs.org/docs/latest/configuration/tooltip.html#tooltip-callbacks and https://www.youtube.com/watch?v=anseX1ePfUw\n\nThis part will be more complex than the previous ones. But we will manage it! üí™\nThe plugins object, used previously to manage the chart title, contains a tooltip element, which in turn contains a callbacks element. It is within this element that we can modify the title and content of the tooltip. Most tooltip elements can be configured via a function call that takes a context element as input. This is a JavaScript object that contains several items related to the hovered point. We will explore the content of this object to extract the information we need later when customizing the tooltip content.\nWe modify our JS handler by including a fixed title (we could also have passed it as a parameter):\nconst tooltip = {\n  callbacks: {\n    title: function (context) {\n      return \"Tooltip title\";\n    },\n  },\n};\n\nconst plugins = {\n  title: {\n    display: true,\n    text: arg.mainTitle,\n    color: arg.mainTitleColor,\n  },\n  tooltip: tooltip\n};\nLet‚Äôs see if it works:\n\nThe application code for this step is available here: https://github.com/ymansiaux/golemchartjs/tree/step9\nLet‚Äôs proceed with customizing the tooltip content!\nIn this step, we will modify the label parameter in the tooltip object. To refine our code, we will use the debugger function, which we haven‚Äôt used so far! If you are familiar with using browser() in R, debugger is its JavaScript equivalent. It allows you to pause the code execution and open the browser console to explore the arguments passed to a function.\nLet‚Äôs modify our handler:\nconst tooltip = {\n  callbacks: {\n    title: function (context) {\n      return \"Tooltip title\";\n    },\n    label: function(context) {\n      debugger;\n    }\n  },\n};\n\nconst plugins = {\n  title: {\n    display: true,\n    text: arg.mainTitle,\n    color: arg.mainTitleColor,\n  },\n  tooltip: tooltip,\n};\nWe add a call to the JavaScript debugger in the label function of the callbacks object. We restart our application:\n\nWhen hovering over a point on the chart, code execution is paused and the browser console opens. We can then explore the content of the context object passed to the label function.\nWe can identify the information that will be useful:\n\nThe row number in the dataset: context.dataIndex\nThe values of the point: context.formattedValue\n\nWe can then construct a customized tooltip (remembering to remove the debugger call üòâ):\nconst tooltip = {\n  callbacks: {\n    title: function (context) {\n      return \"Tooltip title\";\n    },\n    label: function (context) {\n      lab =\n        \"Line number: \" +\n        context.dataIndex +\n        \" values: \" +\n        context.formattedValue;\n      return lab;\n      },\n  },\n};\n\nconst plugins = {\n  title: {\n    display: true,\n    text: arg.mainTitle,\n    color: arg.mainTitleColor,\n  },\n  tooltip: tooltip,\n};\n\nMission accomplished! üöÄ\nThe code for this step is available here: https://github.com/ymansiaux/golemchartjs/tree/step10"
  },
  {
    "objectID": "posts/chartJS/index.html#conclusion",
    "href": "posts/chartJS/index.html#conclusion",
    "title": "Boost your shiny app with sparkling data visualizations: A deep dive into Chart.js JavaScript library",
    "section": "Conclusion",
    "text": "Conclusion\nAfter our initial foray into calling JavaScript code from R with the sweetalert2 library, we have now explored using a data visualization library.\nKey takeaways:\n\nAlways try to get the documentation examples working before adapting them to your application.\nUse jsonlite::toJSON() to verify that the data passed is in the format expected by the library.\nKeep in mind that sometimes you need to ‚Äúupdate‚Äù or ‚Äúdestroy‚Äù objects on a web page.\nUse console.log() or debugger to see the contents of a JavaScript object passed as an argument to a function.\n\nAfter overcoming some challenging moments, we can see the possibilities offered by JavaScript data visualization libraries. You can achieve a high degree of customization for your charts, and Chart.js offers many features. Documentation, combined with research on discussion forums, can help solve problems that may seem insurmountable at first.\nFeel free to dive into integrating JavaScript libraries into your {shiny} applications. It can be an excellent way to break new ground and offer interactive and customized charts to your users.\nSee you soon for new adventures! üöÄ"
  },
  {
    "objectID": "posts/sweetalert2/index.html",
    "href": "posts/sweetalert2/index.html",
    "title": "Pimping your {shiny} app with a JavaScript library : an example using sweetalert2",
    "section": "",
    "text": "You think that some of the components of {shiny} are not very functional or downright austere? Are you looking to implement some feature in your app but it is not available in the {shiny} toolbox? Take a look at JavaScript!\nJavaScript is a very popular programming language that is often used to add features to web pages. With HTML and CSS, JavaScript is an essential language for web developers. The size of its user community means that if you are looking to implement a particular feature, there is a good chance that someone has already had the same need as you and has shared their code!\nAn other positive point (and essential for us in this case) : it is possible to integrate JavaScript libraries into a {shiny} application to add features that are not available by default. In addition to that, {golem} will help us to set everything up.\nNo more excuses to back down, let‚Äôs go ! üöÄ"
  },
  {
    "objectID": "posts/sweetalert2/index.html#tldr",
    "href": "posts/sweetalert2/index.html#tldr",
    "title": "Pimping your {shiny} app with a JavaScript library : an example using sweetalert2",
    "section": "TL;DR",
    "text": "TL;DR\n\nGoing further in {shiny} by integrating a JavaScript library is possible!\n\nWe take the example of sweetalert2, which allows to display alerts that are more visually appealing than the basic ones\n{golem} has several functions to make it easier for us to integrate JavaScript libraries into a {shiny} app\nThis example is rather simple. The integration of libraries is sometimes harder because the documentation might be scarse or the library might be more complex to use"
  },
  {
    "objectID": "posts/sweetalert2/index.html#import-sweetalert2-into-a-shiny-app-created-with-golem",
    "href": "posts/sweetalert2/index.html#import-sweetalert2-into-a-shiny-app-created-with-golem",
    "title": "Pimping your {shiny} app with a JavaScript library : an example using sweetalert2",
    "section": "Import sweetalert2 into a {shiny} app created with {golem}",
    "text": "Import sweetalert2 into a {shiny} app created with {golem}\n\nsweetalert2\n\nsweetalert2 is a JavaScript library that allows you to display alerts that are more visually appealing than the basic ones\nIt is very well documented\nIt is very popular (more than 16000 ‚Äústars‚Äù on GitHub at the time of publication of this article)\n\nLet‚Äôs take a look at the possibilities offered by sweetalert2: https://sweetalert2.github.io/\n\n\n\n\n\n\n\n\n\nIf you click on ‚ÄúShow normal alert‚Äù, you will see a classic alert while clicking on ‚ÄúShow success message‚Äù, you will see a sweetalert2 alert.\nThe first one has a rather austere design while the second one is more modern and more pleasant to the eye, it will probably offer a better user experience.\nFeel free to play with the different types of alerts offered by sweetalert2 to get an idea of what is possible with this library by visiting the examples section.\n\n\nAdd the necessary dependencies to the {shiny} app\nThe following sections assume that you have already created a {shiny} app with {golem}.\nIf this is not the case and you want to know more about {golem}, I invite you to consult the official documentation.\nTo add sweetalert2 to your {shiny} app, you will need to find a way to incorporate the files needed for its operation into your application.\nTwo solutions are available to you:\n\nUse a ‚ÄúCDN‚Äù (Content Delivery Network) to load the files from a third-party server. The CDN will be the equivalent of a CRAN for JavaScript libraries. Concretely, we will ask our application to point to the sources of sweetalert2, hosted on a remote server.\nDownload the files needed for its operation and integrate them directly into your application. If your application is intended to be used on a machine that is not connected to the Internet, you will inevitably have to go through this step.\n\nDon‚Äôt panic! We will see both methods\n\nWhere to find the elements I need?\nThe sweetalert2 documentation is very well done. You will find all the information you need to integrate the library into your application from the Download section.\nHowever, you will need to learn how to identify the elements you need to integrate sweetalert2 into your application.\nLooking for the CDN\nIn the ‚ÄúDownload & Install‚Äù section, you will find a link to the sweetalert2 CDN. This is the link that we will have to add to our application in order to use the library.\n\n\n\n\n\n\n\n\n\nWhen you click on the link, you will arrive on a page that looks like this:\n\n\n\n\n\n\n\n\n\nWhat we are interested in here is the link in the &lt;script&gt; tag and the link in the &lt;link&gt; tag. The link to the file with the .js extension corresponds to the sweetalert2 JavaScript file. The link to the file with the .css extension corresponds to the sweetalert2 styles file.\nCopy them and let‚Äôs go back to our app!\n\n\nMethod 1: Add dependencies to sweetalert2 via the CDN\nLet‚Äôs open the R/app_ui.R file of our application and add the two links we copied earlier to the body of the golem_add_external_resources() function.\ngolem_add_external_resources &lt;- function() {\n  add_resource_path(\n    \"www\",\n    app_sys(\"app/www\")\n  )\n\n  tags$head(\n    favicon(),\n    bundle_resources(\n      path = app_sys(\"app/www\"),\n      app_title = \"golemsweetalert\"\n    ),\n    # sweetalert2\n    tags$script(src = \"https://cdn.jsdelivr.net/npm/sweetalert2@11.10.7/dist/sweetalert2.all.min.js\"),\n    tags$link(href = \"https://cdn.jsdelivr.net/npm/sweetalert2@11.10.7/dist/sweetalert2.min.css\",\n              rel=\"stylesheet\")\n \n  )\n}\nWe find here a call to tags$script and a call to tags$link corresponding respectively to the &lt;script&gt; and &lt;link&gt; tags seen on the links provided by the CDN.\nWe copy-paste the elements being careful about the parameter names src, href and rel and remembering to separate them with commas. We are indeed moving from HTML code (where elements are separated by spaces) to R code.\n\n\nMethod 2: Add dependencies to sweetalert2 locally\nThe links identified earlier will also be useful to download the files needed to use sweetalert2.\nThe link to the JavaScript file will be passed to the golem::use_external_js_file() function while the link to the CSS file will be passed to the golem::use_external_css_file() function.\nTo keep a record of this, we will save the following commands in the dev/02_dev.R file in the ‚ÄúExternal resources‚Äù section.\ngolem::use_external_js_file(\"https://cdn.jsdelivr.net/npm/sweetalert2@11.10.7/dist/sweetalert2.all.min.js\")\ngolem::use_external_css_file(\"https://cdn.jsdelivr.net/npm/sweetalert2@11.10.7/dist/sweetalert2.min.css\")\nBoth files are now present in the inst/app/www folder of our application project.\n\n\n\n\n\n\n\n\n\nEverything is ok, we can continue our journey üëç.\n\n\n\nHow to know if sweetalert2 is correctly imported into my {shiny} app?\nTo check that sweetalert2 is correctly imported into our application, we open our browser and then the development console.\nBefore that, let‚Äôs launch our app with golem::run_dev()!\nNB: The following screenshots were taken with the Google Chrome browser.\nOn the window of our application, we right-click and select ‚ÄúInspect‚Äù. In the new window that opens, we choose the ‚ÄúConsole‚Äù tab and then type the command Swal.fire(\"Hello sweetalert2!\"). This console allows us to execute JavaScript code, which will be interpreted by our browser.\nIf everything went well, we should see a sweetalert2 alert appear! Otherwise, we might have an error message in red (which we will have to learn to decipher, as with an R console :-)).\n\n\n\n\n\n\n\n\n\nIt works! üéâ\n\nHow did I know I had to type Swal.fire(\" .... \")?\nThanks to the documentation! By going to the sweetalert2 page, we find many examples of using the library. In this case, to display an alert, you have to use the Swal.fire() function. As for learning a new R package, we see that documentation (when it exists ‚Ä¶) is of paramount importance for the handling of JavaScript libraries."
  },
  {
    "objectID": "posts/sweetalert2/index.html#create-a-sweetalert2-alert-in-our-shiny-app",
    "href": "posts/sweetalert2/index.html#create-a-sweetalert2-alert-in-our-shiny-app",
    "title": "Pimping your {shiny} app with a JavaScript library : an example using sweetalert2",
    "section": "Create a sweetalert2 alert in our {shiny} app",
    "text": "Create a sweetalert2 alert in our {shiny} app\nNow that we have imported sweetalert2 into our application and checked that the import went well, we are going to create a function that will allow us to call sweetalert2 from our application.\nWe are going to try to incorporate the ‚ÄúA title with a text under‚Äù alert into our application.\n\n\n\n\n\n\n\n\n\nThree elements can be set here: - The title of the alert - The text of the alert - The type of alert (success, error, warning, info, question) and its associated icon\n\n\n\n\n\n\n\n\n\nWe can easily imagine how to modify these elements directly in the JavaScript code but we don‚Äôt know yet how to create this alert via R code. Let‚Äôs go!\n\nCreate a JavaScript file to call sweetalert2\nIn order to call sweetalert2 from our application, we are going to create a JavaScript file in which we will write a function that will allow us to create an alert.\nLet‚Äôs create a inst/app/www/sweet_alert.js file in which we will paste the code to create the alert selected earlier. We could have created this file manually, but we will take advantage of the features offered by {golem} to do so.\nLet‚Äôs go to the dev/02_dev.R file! We add the following line in the ‚ÄúExternal Resources‚Äù section:\ngolem::add_js_handler(\"sweet_alert\")\nThe file name doesn‚Äôt matter, but it is important to respect the .js extension so that the file is correctly interpreted as JavaScript code. We could have also created subfolders if we had had many imports and files to manage. The only prerequisite is that everything is located in the inst/app/www directory.\nWe obtain a slightly strange skeleton, which will in fact be the skeleton of a JavaScript function, usable in our {shiny} application:\n$( document ).ready(function() {\n  Shiny.addCustomMessageHandler('fun', function(arg) {\n \n  })\n});\nWe are going to substitute the term 'fun' with the name of the function we want to call in our {shiny} application and add the code to create the sweetalert2 alert.\nWe therefore obtain the following code:\n$( document ).ready(function() {\n  Shiny.addCustomMessageHandler('alert_title_and_text_under', function(arg) {\n    Swal.fire({\n      title: \"The Internet?\",\n      text: \"That thing is still around?\",\n      icon: \"question\"\n    });\n  })\n});\nOur parameters ‚Äútitle‚Äù, ‚Äútext‚Äù and ‚Äúicon‚Äù are fixed, we need to find a way to make them vary according to the choices of the user. We can notice the existence of a ‚Äúarg‚Äù parameter in the Shiny.addCustomMessageHandler() function. It is this parameter that will allow us to transmit information to our JavaScript function.\nLet‚Äôs modify our code:\n$( document ).ready(function() {\n  Shiny.addCustomMessageHandler('alert_title_and_text_under', function(arg) {\n    Swal.fire({\n      title: arg.title,\n      text: arg.text,\n      icon: arg.icon\n    });\n  })\n});\nThe notation to use here will be arg.parameter_name to access the values transmitted by our {shiny} application. The notation with the ‚Äú.‚Äù is a JavaScript convention for accessing object properties. To make the parallel with R, it‚Äôs a bit like if we were doing arg$parameter_name.\nOur JavaScript code is ready! Let‚Äôs move back to the R side!\n\n\nWhat if we tested all this in our {shiny} app (FINALLY!)?\nWe are going to add a button in the R/app_ui.R file:\napp_ui &lt;- function(request) {\n  tagList(\n    # Leave this function for adding external resources\n    golem_add_external_resources(),\n    # Your application UI logic\n    fluidPage(\n      h1(\"golemsweetalert\"),\n      actionButton(inputId = \"show_alert\",\n                   label = \"Alert demo\")\n    )\n  )\n}\nOn the server side, we add an observeEvent() in the R/app_server.R file, which will call our JavaScript function to generate an alert when the user clicks on the ‚ÄúAlert demo‚Äù button.\nOnce more, {golem} will make our life easier! We will use the golem::invoke_js() function to call our JavaScript function.\nTwo parameters are passed to golem::invoke_js():\n\nthe first parameter corresponds to the name of the JavaScript function to call\nthe second parameter corresponds to a list of parameters, the JavaScript equivalent of our arg object which will be used to transmit the information necessary to create the sweetalert2 alert. The names used in the list here must correspond to the names used in the JavaScript function for the arg parameter (‚Äútitle‚Äù, ‚Äútext‚Äù and ‚Äúicon‚Äù).\n\napp_server &lt;- function(input, output, session) {\n  # Your application server logic\n  observeEvent(\n    input$show_alert,{\n      golem::invoke_js(\n        \"alert_title_and_text_under\",\n        list(\n          title = \"Title\",\n          text = \"Text\",\n          icon = \"success\"\n        ))\n    }\n  )\n}\nWe run a call to golem::run_dev() to see our application in action!\n\n\n\n\n\n\n\n\n\nCongratulations! üëè\nTo make everything more elegant, we can create an R function that will call golem::invoke_js().\n\n\nCreate an R function to call sweetalert2\nWe are going to go through {golem} to create our function. To do this, we will add the following line in the dev/02_dev.R file of our application:\ngolem::add_fct(\"create_alert_title_and_text_under\")\nWe obtain a R/fct_create_alert_title_and_text_under.R file in which we will be able to write our function, which will call the JavaScript code created in the previous step.\n#' create_alert_title_and_text_under\n#'\n#' @description Creates an alert with a title, a text and an icon\n#' @param title alert title\n#' @param text alert text\n#' @param icon alert icon\n#' @return side effect : creates an alert\n#'\n#' @noRd\ncreate_alert_title_and_text_under &lt;- function(\n    title = \"Title\",\n    text = \"Text\",\n    icon = \"success\"\n    ) {\n  golem::invoke_js(\n    \"alert_title_and_text_under\",\n    list(\n      title = title,\n      text = text,\n      icon = icon\n    )\n  )\n}\nLet‚Äôs modify both the R/app_ui.R and R/app_server.R files to be able to define the parameters of our alert through choices made by the user.\napp_ui &lt;- function(request) {\n  tagList(\n    # Leave this function for adding external resources\n    golem_add_external_resources(),\n    # Your application UI logic\n    fluidPage(\n      h1(\"golemsweetalert\"),\n      textInput(inputId = \"title\",\n                label = \"title\"),\n      textInput(inputId = \"text\",\n                label = \"text\"),\n      radioButtons(inputId = \"icon\",\n                   label = \"icon\",\n                   choices = c(\"warning\", \"error\", \"success\", \"info\", \"question\")),\n      actionButton(inputId = \"show_alert\",\n                   label = \"Alert demo\")\n    )\n  )\n}\nTo define the list of possible ‚Äúchoices‚Äù for the radioButtons, we took the possible values for the icon parameter of sweetalert2, as indicated in the official documentation: https://sweetalert2.github.io/#icon.\napp_server &lt;- function(input, output, session) {\n  # Your application server logic\n  observeEvent(\n    input$show_alert,{\n      create_alert_title_and_text_under(\n        title = input$title,\n        text = input$text,\n        icon = input$icon\n      )\n    }\n  )\n}\nLet‚Äôs finally call golem::run_dev()!\n\n\n\n\n\n\n\n\n\nBravo ! üëè"
  },
  {
    "objectID": "posts/sweetalert2/index.html#and-a-more-complex-example",
    "href": "posts/sweetalert2/index.html#and-a-more-complex-example",
    "title": "Pimping your {shiny} app with a JavaScript library : an example using sweetalert2",
    "section": "And a more complex example?",
    "text": "And a more complex example?\nFollowing the previous steps, it is relatively easy to add additional elements to an alert, such as an image or confirmation / cancellation buttons. A slightly deeper dive into the sweetalert2 documentation will help you understand how to add these elements.\nLet‚Äôs see what is possible to achieve:\n\n\n\n\n\n\n\n\n\nYou are curious to know more? Go to this project source code."
  },
  {
    "objectID": "posts/sweetalert2/index.html#conclusion",
    "href": "posts/sweetalert2/index.html#conclusion",
    "title": "Pimping your {shiny} app with a JavaScript library : an example using sweetalert2",
    "section": "Conclusion",
    "text": "Conclusion\n\nIntegrating JavaScript libraries into a {shiny} application is possible!\n{golem} makes it easier for us\nIt is quite easy when the library is well documented\nIt is important to read the documentation of the library you want to integrate (but this is also true in R!)\nThe browser inspector is a very useful tool to check that everything is going well\nTo integrate more complex libraries, minimal JavaScript skills will probably be required\n\nIf you want more examples of the use of sweetalert2, but also other JavaScript libraries (Grid.js and Chart.js), you can consult the mycomicslibrary application and take a look at its source code.\nThanks for reading this tutorial and have fun in the wonderful world of JavaScript! üöÄ"
  },
  {
    "objectID": "posts/datainpkgs/index.html",
    "href": "posts/datainpkgs/index.html",
    "title": "Beyond Functions: How to Enrich an R Package with Data",
    "section": "",
    "text": "As package developers, we often focus on custom functions, their documentation, and unit testing. To provide a more complete user experience, it can be helpful to include data within the package. Here‚Äôs everything you need to know!"
  },
  {
    "objectID": "posts/datainpkgs/index.html#short-on-time-heres-the-gist",
    "href": "posts/datainpkgs/index.html#short-on-time-heres-the-gist",
    "title": "Beyond Functions: How to Enrich an R Package with Data",
    "section": "Short on time? Here‚Äôs the gist",
    "text": "Short on time? Here‚Äôs the gist\nIn this article, we present the different ways to incorporate data (broadly defined) into an R package. We cover the three directories used for storing data and explain how to access them, whether you are a package user or a developer. Finally, we discuss best practices for documenting these data."
  },
  {
    "objectID": "posts/datainpkgs/index.html#why-include-data-in-a-package",
    "href": "posts/datainpkgs/index.html#why-include-data-in-a-package",
    "title": "Beyond Functions: How to Enrich an R Package with Data",
    "section": "Why Include Data in a Package?",
    "text": "Why Include Data in a Package?\nIncluding data in a package can be useful for several reasons:\n\nSimplifying package usage: The data included in the package is directly accessible to users.\nFacilitating reproducibility: The data allows users to replicate the examples provided in the documentation.\nEnhancing unit testing: The included data can be used for testing the package functions.\nSharing information: Distributing documentation, scientific articles, code samples, etc.\n\nHere, ‚Äúdata‚Äù should be interpreted broadly. It includes tabular data typically used in R (e.g., CSV or XLSX files, or data.frame objects), but also images, configuration files, articles, code samples, etc."
  },
  {
    "objectID": "posts/datainpkgs/index.html#data-directories-in-an-r-package",
    "href": "posts/datainpkgs/index.html#data-directories-in-an-r-package",
    "title": "Beyond Functions: How to Enrich an R Package with Data",
    "section": "Data Directories in an R Package",
    "text": "Data Directories in an R Package\nThere are three directories in an R package used to store data: data-raw/, data/, and inst/, each serving a specific purpose and catering to different audiences (developers vs.¬†users).\n\nThe data-raw/ and data/ Pair\nThe goal here is to make data available to package users, which can be used by the package‚Äôs functions or included in the documentation examples. These data will be represented as R objects (e.g., data.frame, list, etc.).\n\n\nThe inst/ Directory\nThis directory allows you to store files without format restrictions: tabular files, code sample scripts, notebooks in Rmd/Qmd format, PDF documentation, etc. There are no limits."
  },
  {
    "objectID": "posts/datainpkgs/index.html#using-data-raw-data",
    "href": "posts/datainpkgs/index.html#using-data-raw-data",
    "title": "Beyond Functions: How to Enrich an R Package with Data",
    "section": "Using data-raw/ + data/",
    "text": "Using data-raw/ + data/\nUse case: You want to make data available to package users that can be used by the package‚Äôs functions. The goal is to provide native access from the package‚Äôs functions. You‚Äôre probably familiar with preloaded datasets in R like mtcars or iris; this follows the same principle.\n\ndata-raw/\nThe data-raw/ folder is used to store scripts for preparing the data. Files in this folder are not included in the final package installed on the user‚Äôs computer but contain the code needed to generate the datasets that will later be included in the package.\n\n\ndata/\nOnce prepared in data-raw/, the data is stored in the data/ folder. Files in this folder are included in the final package and are accessible to users. The files are stored in .rda format and are loaded when a user runs library(mypackage).\n\n\n\nExample\n\nCreate the data-raw/ folder using the command usethis::use_data_raw(\"my_dataset_demo\"). This command creates a my_dataset_demo.R file in the data-raw/ folder.\nPrepare the dataset in the my_dataset_demo.R file:\n\n# Create a sample of the \"starwars\" dataset from the dplyr package\n# See https://github.com/tidyverse/dplyr/tree/main/data-raw and https://github.com/tidyverse/dplyr/tree/main/data\nlibrary(dplyr)\nlibrary(readr)\nstarwars_raw &lt;- read_csv(\"data-raw/starwars.csv\")\nstarwars_sample &lt;- starwars_raw |&gt;\n  sample_n(size = 10)\nusethis::use_data(starwars_sample, overwrite = TRUE)\n\nAfter running the command usethis::use_data(starwars_sample, overwrite = TRUE), you‚Äôll see a file named starwars_sample.rda in the data/ folder.\nThere‚Äôs still some work to do: now we need to document the dataset. For this, we will use the {checkhelper} package.\n\ncheckhelper::use_data_doc(\"starwars_sample\")\nThis creates a doc_starwars_sample.R file in the package‚Äôs R/ folder. The file contains the dataset‚Äôs documentation. You can now edit this file to add more information about the dataset\n`r     #' starwars_sample #' #' Description. #' #' @format A data frame with 10 rows and 14 variables: #' \\describe{ #'   \\item{ name }{ The character's name } #'   \\item{ height }{ numeric } #'   \\item{ mass }{ numeric } #'   \\item{ hair_color }{ character } #'   \\item{ skin_color }{ character } #'   \\item{ eye_color }{ character } #'   \\item{ birth_year }{ numeric } #'   \\item{ sex }{ character } #'   \\item{ gender }{ character } #'   \\item{ homeworld }{ character } #'   \\item{ species }{ character } #'   \\item{ films }{ character } #'   \\item{ vehicles }{ character } #'   \\item{ starships }{ character } #' } #' @source Source \"starwars_sample\" While the overall structure of the file should be preserved, you can edit the description, format, and source information as needed.\nFinally, generate the LaTeX documentation using the command devtools::document() or attachment::att_amend_desc().\nOnce your package is installed and loaded, you can access the dataset using the command data(\"starwars_sample\")."
  },
  {
    "objectID": "posts/datainpkgs/index.html#using-inst",
    "href": "posts/datainpkgs/index.html#using-inst",
    "title": "Beyond Functions: How to Enrich an R Package with Data",
    "section": "Using inst/",
    "text": "Using inst/\nUse case: You want to store files intended for use only in unit tests or to share additional documentation (e.g., a scientific article).\n\n\nExample\n\nCreate the inst/ folder at the package root: dir.create(here::here(\"inst\")).\nPlace the desired files in the folder.\nInstall the package.\nThe files are now accessible using a special function: system.file(), which points to the root of the inst/ directory. For example, to access a file named article.pdf in the inst/ folder, you would use system.file(\"article.pdf\", package = \"mypackage\"). If the file is in a subfolder called ‚Äúdoc,‚Äù you would use system.file(\"doc\", \"article.pdf\", package = \"mypackage\").\n\nNote: system.file() does not read a file; it only returns the file path."
  },
  {
    "objectID": "posts/datainpkgs/index.html#conclusion",
    "href": "posts/datainpkgs/index.html#conclusion",
    "title": "Beyond Functions: How to Enrich an R Package with Data",
    "section": "Conclusion",
    "text": "Conclusion\nYou now know all about incorporating data into an R package. You‚Äôve learned how to store data in the data-raw/, data/, and inst/ directories and make it accessible from the package functions. You‚Äôve also learned how to document these data to make them usable for package users.\nWhether the data is intended for users or developers, you now have all the tools to enrich your R package with data. Happy coding!"
  },
  {
    "objectID": "posts/datainpkgs_video/index.html",
    "href": "posts/datainpkgs_video/index.html",
    "title": "Include a demo dataset in a R package (video tutorial)",
    "section": "",
    "text": "Didn‚Äôt have time to read my article on adding data to an R package?\nDon‚Äôt worry! Here‚Äôs a short video to sum it all up:\n\nEnjoy üçø"
  },
  {
    "objectID": "posts/vscodeR/index.html",
    "href": "posts/vscodeR/index.html",
    "title": "VSCode for R users",
    "section": "",
    "text": "A few months ago, I switched from RStudio to Visual Studio Code for my R programming. I was a bit reluctant at first, but I am now convinced that it was a good move.\nCurrently I have 3 articles dedicated to VSCode for R users. They are only available in French for the moment.\nI‚Äôll update and translate them soon.\nYou can find them here:\n\nFaire du R dans VSCode ? M√™me pas peur !\nPoursuivons notre route avec VSCode : les projets, les scripts, les notebooks ‚Ä¶ tout est l√† !\nCr√©er un package R et le versionner avec VSCode ? Mission possible !\n\nStay tuned!"
  },
  {
    "objectID": "posts/tmap/index.html",
    "href": "posts/tmap/index.html",
    "title": "Pimping your {shiny} app with a JavaScript library : an example using sweetalert2",
    "section": "",
    "text": "You think that some of the components of {shiny} are not very functional or downright austere? Are you looking to implement some feature in your app but it is not available in the {shiny} toolbox? Take a look at JavaScript!\nJavaScript is a very popular programming language that is often used to add features to web pages. With HTML and CSS, JavaScript is an essential language for web developers. The size of its user community means that if you are looking to implement a particular feature, there is a good chance that someone has already had the same need as you and has shared their code!\nAn other positive point (and essential for us in this case) : it is possible to integrate JavaScript libraries into a {shiny} application to add features that are not available by default. In addition to that, {golem} will help us to set everything up.\nNo more excuses to back down, let‚Äôs go ! üöÄ"
  },
  {
    "objectID": "posts/tmap/index.html#tldr",
    "href": "posts/tmap/index.html#tldr",
    "title": "Pimping your {shiny} app with a JavaScript library : an example using sweetalert2",
    "section": "TL;DR",
    "text": "TL;DR\n\nGoing further in {shiny} by integrating a JavaScript library is possible!\n\nWe take the example of sweetalert2, which allows to display alerts that are more visually appealing than the basic ones\n{golem} has several functions to make it easier for us to integrate JavaScript libraries into a {shiny} app\nThis example is rather simple. The integration of libraries is sometimes harder because the documentation might be scarse or the library might be more complex to use"
  },
  {
    "objectID": "posts/tmap/index.html#import-sweetalert2-into-a-shiny-app-created-with-golem",
    "href": "posts/tmap/index.html#import-sweetalert2-into-a-shiny-app-created-with-golem",
    "title": "Pimping your {shiny} app with a JavaScript library : an example using sweetalert2",
    "section": "Import sweetalert2 into a {shiny} app created with {golem}",
    "text": "Import sweetalert2 into a {shiny} app created with {golem}\n\nsweetalert2\n\nsweetalert2 is a JavaScript library that allows you to display alerts that are more visually appealing than the basic ones\nIt is very well documented\nIt is very popular (more than 16000 ‚Äústars‚Äù on GitHub at the time of publication of this article)\n\nLet‚Äôs take a look at the possibilities offered by sweetalert2: https://sweetalert2.github.io/\n\n\n\n\n\n\n\n\n\nIf you click on ‚ÄúShow normal alert‚Äù, you will see a classic alert while clicking on ‚ÄúShow success message‚Äù, you will see a sweetalert2 alert.\nThe first one has a rather austere design while the second one is more modern and more pleasant to the eye, it will probably offer a better user experience.\nFeel free to play with the different types of alerts offered by sweetalert2 to get an idea of what is possible with this library by visiting the examples section.\n\n\nAdd the necessary dependencies to the {shiny} app\nThe following sections assume that you have already created a {shiny} app with {golem}.\nIf this is not the case and you want to know more about {golem}, I invite you to consult the official documentation.\nTo add sweetalert2 to your {shiny} app, you will need to find a way to incorporate the files needed for its operation into your application.\nTwo solutions are available to you:\n\nUse a ‚ÄúCDN‚Äù (Content Delivery Network) to load the files from a third-party server. The CDN will be the equivalent of a CRAN for JavaScript libraries. Concretely, we will ask our application to point to the sources of sweetalert2, hosted on a remote server.\nDownload the files needed for its operation and integrate them directly into your application. If your application is intended to be used on a machine that is not connected to the Internet, you will inevitably have to go through this step.\n\nDon‚Äôt panic! We will see both methods\n\nWhere to find the elements I need?\nThe sweetalert2 documentation is very well done. You will find all the information you need to integrate the library into your application from the Download section.\nHowever, you will need to learn how to identify the elements you need to integrate sweetalert2 into your application.\nLooking for the CDN\nIn the ‚ÄúDownload & Install‚Äù section, you will find a link to the sweetalert2 CDN. This is the link that we will have to add to our application in order to use the library.\n\n\n\n\n\n\n\n\n\nWhen you click on the link, you will arrive on a page that looks like this:\n\n\n\n\n\n\n\n\n\nWhat we are interested in here is the link in the &lt;script&gt; tag and the link in the &lt;link&gt; tag. The link to the file with the .js extension corresponds to the sweetalert2 JavaScript file. The link to the file with the .css extension corresponds to the sweetalert2 styles file.\nCopy them and let‚Äôs go back to our app!\n\n\nMethod 1: Add dependencies to sweetalert2 via the CDN\nLet‚Äôs open the R/app_ui.R file of our application and add the two links we copied earlier to the body of the golem_add_external_resources() function.\ngolem_add_external_resources &lt;- function() {\n  add_resource_path(\n    \"www\",\n    app_sys(\"app/www\")\n  )\n\n  tags$head(\n    favicon(),\n    bundle_resources(\n      path = app_sys(\"app/www\"),\n      app_title = \"golemsweetalert\"\n    ),\n    # sweetalert2\n    tags$script(src = \"https://cdn.jsdelivr.net/npm/sweetalert2@11.10.7/dist/sweetalert2.all.min.js\"),\n    tags$link(href = \"https://cdn.jsdelivr.net/npm/sweetalert2@11.10.7/dist/sweetalert2.min.css\",\n              rel=\"stylesheet\")\n \n  )\n}\nWe find here a call to tags$script and a call to tags$link corresponding respectively to the &lt;script&gt; and &lt;link&gt; tags seen on the links provided by the CDN.\nWe copy-paste the elements being careful about the parameter names src, href and rel and remembering to separate them with commas. We are indeed moving from HTML code (where elements are separated by spaces) to R code.\n\n\nMethod 2: Add dependencies to sweetalert2 locally\nThe links identified earlier will also be useful to download the files needed to use sweetalert2.\nThe link to the JavaScript file will be passed to the golem::use_external_js_file() function while the link to the CSS file will be passed to the golem::use_external_css_file() function.\nTo keep a record of this, we will save the following commands in the dev/02_dev.R file in the ‚ÄúExternal resources‚Äù section.\ngolem::use_external_js_file(\"https://cdn.jsdelivr.net/npm/sweetalert2@11.10.7/dist/sweetalert2.all.min.js\")\ngolem::use_external_css_file(\"https://cdn.jsdelivr.net/npm/sweetalert2@11.10.7/dist/sweetalert2.min.css\")\nBoth files are now present in the inst/app/www folder of our application project.\n\n\n\n\n\n\n\n\n\nEverything is ok, we can continue our journey üëç.\n\n\n\nHow to know if sweetalert2 is correctly imported into my {shiny} app?\nTo check that sweetalert2 is correctly imported into our application, we open our browser and then the development console.\nBefore that, let‚Äôs launch our app with golem::run_dev()!\nNB: The following screenshots were taken with the Google Chrome browser.\nOn the window of our application, we right-click and select ‚ÄúInspect‚Äù. In the new window that opens, we choose the ‚ÄúConsole‚Äù tab and then type the command Swal.fire(\"Hello sweetalert2!\"). This console allows us to execute JavaScript code, which will be interpreted by our browser.\nIf everything went well, we should see a sweetalert2 alert appear! Otherwise, we might have an error message in red (which we will have to learn to decipher, as with an R console :-)).\n\n\n\n\n\n\n\n\n\nIt works! üéâ\n\nHow did I know I had to type Swal.fire(\" .... \")?\nThanks to the documentation! By going to the sweetalert2 page, we find many examples of using the library. In this case, to display an alert, you have to use the Swal.fire() function. As for learning a new R package, we see that documentation (when it exists ‚Ä¶) is of paramount importance for the handling of JavaScript libraries."
  },
  {
    "objectID": "posts/tmap/index.html#create-a-sweetalert2-alert-in-our-shiny-app",
    "href": "posts/tmap/index.html#create-a-sweetalert2-alert-in-our-shiny-app",
    "title": "Pimping your {shiny} app with a JavaScript library : an example using sweetalert2",
    "section": "Create a sweetalert2 alert in our {shiny} app",
    "text": "Create a sweetalert2 alert in our {shiny} app\nNow that we have imported sweetalert2 into our application and checked that the import went well, we are going to create a function that will allow us to call sweetalert2 from our application.\nWe are going to try to incorporate the ‚ÄúA title with a text under‚Äù alert into our application.\n\n\n\n\n\n\n\n\n\nThree elements can be set here: - The title of the alert - The text of the alert - The type of alert (success, error, warning, info, question) and its associated icon\n\n\n\n\n\n\n\n\n\nWe can easily imagine how to modify these elements directly in the JavaScript code but we don‚Äôt know yet how to create this alert via R code. Let‚Äôs go!\n\nCreate a JavaScript file to call sweetalert2\nIn order to call sweetalert2 from our application, we are going to create a JavaScript file in which we will write a function that will allow us to create an alert.\nLet‚Äôs create a inst/app/www/sweet_alert.js file in which we will paste the code to create the alert selected earlier. We could have created this file manually, but we will take advantage of the features offered by {golem} to do so.\nLet‚Äôs go to the dev/02_dev.R file! We add the following line in the ‚ÄúExternal Resources‚Äù section:\ngolem::add_js_handler(\"sweet_alert\")\nThe file name doesn‚Äôt matter, but it is important to respect the .js extension so that the file is correctly interpreted as JavaScript code. We could have also created subfolders if we had had many imports and files to manage. The only prerequisite is that everything is located in the inst/app/www directory.\nWe obtain a slightly strange skeleton, which will in fact be the skeleton of a JavaScript function, usable in our {shiny} application:\n$( document ).ready(function() {\n  Shiny.addCustomMessageHandler('fun', function(arg) {\n \n  })\n});\nWe are going to substitute the term 'fun' with the name of the function we want to call in our {shiny} application and add the code to create the sweetalert2 alert.\nWe therefore obtain the following code:\n$( document ).ready(function() {\n  Shiny.addCustomMessageHandler('alert_title_and_text_under', function(arg) {\n    Swal.fire({\n      title: \"The Internet?\",\n      text: \"That thing is still around?\",\n      icon: \"question\"\n    });\n  })\n});\nOur parameters ‚Äútitle‚Äù, ‚Äútext‚Äù and ‚Äúicon‚Äù are fixed, we need to find a way to make them vary according to the choices of the user. We can notice the existence of a ‚Äúarg‚Äù parameter in the Shiny.addCustomMessageHandler() function. It is this parameter that will allow us to transmit information to our JavaScript function.\nLet‚Äôs modify our code:\n$( document ).ready(function() {\n  Shiny.addCustomMessageHandler('alert_title_and_text_under', function(arg) {\n    Swal.fire({\n      title: arg.title,\n      text: arg.text,\n      icon: arg.icon\n    });\n  })\n});\nThe notation to use here will be arg.parameter_name to access the values transmitted by our {shiny} application. The notation with the ‚Äú.‚Äù is a JavaScript convention for accessing object properties. To make the parallel with R, it‚Äôs a bit like if we were doing arg$parameter_name.\nOur JavaScript code is ready! Let‚Äôs move back to the R side!\n\n\nWhat if we tested all this in our {shiny} app (FINALLY!)?\nWe are going to add a button in the R/app_ui.R file:\napp_ui &lt;- function(request) {\n  tagList(\n    # Leave this function for adding external resources\n    golem_add_external_resources(),\n    # Your application UI logic\n    fluidPage(\n      h1(\"golemsweetalert\"),\n      actionButton(inputId = \"show_alert\",\n                   label = \"Alert demo\")\n    )\n  )\n}\nOn the server side, we add an observeEvent() in the R/app_server.R file, which will call our JavaScript function to generate an alert when the user clicks on the ‚ÄúAlert demo‚Äù button.\nOnce more, {golem} will make our life easier! We will use the golem::invoke_js() function to call our JavaScript function.\nTwo parameters are passed to golem::invoke_js():\n\nthe first parameter corresponds to the name of the JavaScript function to call\nthe second parameter corresponds to a list of parameters, the JavaScript equivalent of our arg object which will be used to transmit the information necessary to create the sweetalert2 alert. The names used in the list here must correspond to the names used in the JavaScript function for the arg parameter (‚Äútitle‚Äù, ‚Äútext‚Äù and ‚Äúicon‚Äù).\n\napp_server &lt;- function(input, output, session) {\n  # Your application server logic\n  observeEvent(\n    input$show_alert,{\n      golem::invoke_js(\n        \"alert_title_and_text_under\",\n        list(\n          title = \"Title\",\n          text = \"Text\",\n          icon = \"success\"\n        ))\n    }\n  )\n}\nWe run a call to golem::run_dev() to see our application in action!\n\n\n\n\n\n\n\n\n\nCongratulations! üëè\nTo make everything more elegant, we can create an R function that will call golem::invoke_js().\n\n\nCreate an R function to call sweetalert2\nWe are going to go through {golem} to create our function. To do this, we will add the following line in the dev/02_dev.R file of our application:\ngolem::add_fct(\"create_alert_title_and_text_under\")\nWe obtain a R/fct_create_alert_title_and_text_under.R file in which we will be able to write our function, which will call the JavaScript code created in the previous step.\n#' create_alert_title_and_text_under\n#'\n#' @description Creates an alert with a title, a text and an icon\n#' @param title alert title\n#' @param text alert text\n#' @param icon alert icon\n#' @return side effect : creates an alert\n#'\n#' @noRd\ncreate_alert_title_and_text_under &lt;- function(\n    title = \"Title\",\n    text = \"Text\",\n    icon = \"success\"\n    ) {\n  golem::invoke_js(\n    \"alert_title_and_text_under\",\n    list(\n      title = title,\n      text = text,\n      icon = icon\n    )\n  )\n}\nLet‚Äôs modify both the R/app_ui.R and R/app_server.R files to be able to define the parameters of our alert through choices made by the user.\napp_ui &lt;- function(request) {\n  tagList(\n    # Leave this function for adding external resources\n    golem_add_external_resources(),\n    # Your application UI logic\n    fluidPage(\n      h1(\"golemsweetalert\"),\n      textInput(inputId = \"title\",\n                label = \"title\"),\n      textInput(inputId = \"text\",\n                label = \"text\"),\n      radioButtons(inputId = \"icon\",\n                   label = \"icon\",\n                   choices = c(\"warning\", \"error\", \"success\", \"info\", \"question\")),\n      actionButton(inputId = \"show_alert\",\n                   label = \"Alert demo\")\n    )\n  )\n}\nTo define the list of possible ‚Äúchoices‚Äù for the radioButtons, we took the possible values for the icon parameter of sweetalert2, as indicated in the official documentation: https://sweetalert2.github.io/#icon.\napp_server &lt;- function(input, output, session) {\n  # Your application server logic\n  observeEvent(\n    input$show_alert,{\n      create_alert_title_and_text_under(\n        title = input$title,\n        text = input$text,\n        icon = input$icon\n      )\n    }\n  )\n}\nLet‚Äôs finally call golem::run_dev()!\n\n\n\n\n\n\n\n\n\nBravo ! üëè"
  },
  {
    "objectID": "posts/tmap/index.html#and-a-more-complex-example",
    "href": "posts/tmap/index.html#and-a-more-complex-example",
    "title": "Pimping your {shiny} app with a JavaScript library : an example using sweetalert2",
    "section": "And a more complex example?",
    "text": "And a more complex example?\nFollowing the previous steps, it is relatively easy to add additional elements to an alert, such as an image or confirmation / cancellation buttons. A slightly deeper dive into the sweetalert2 documentation will help you understand how to add these elements.\nLet‚Äôs see what is possible to achieve:\n\n\n\n\n\n\n\n\n\nYou are curious to know more? Go to this project source code."
  },
  {
    "objectID": "posts/tmap/index.html#conclusion",
    "href": "posts/tmap/index.html#conclusion",
    "title": "Pimping your {shiny} app with a JavaScript library : an example using sweetalert2",
    "section": "Conclusion",
    "text": "Conclusion\n\nIntegrating JavaScript libraries into a {shiny} application is possible!\n{golem} makes it easier for us\nIt is quite easy when the library is well documented\nIt is important to read the documentation of the library you want to integrate (but this is also true in R!)\nThe browser inspector is a very useful tool to check that everything is going well\nTo integrate more complex libraries, minimal JavaScript skills will probably be required\n\nIf you want more examples of the use of sweetalert2, but also other JavaScript libraries (Grid.js and Chart.js), you can consult the mycomicslibrary application and take a look at its source code.\nThanks for reading this tutorial and have fun in the wonderful world of JavaScript! üöÄ"
  },
  {
    "objectID": "posts/iaforr/index.html",
    "href": "posts/iaforr/index.html",
    "title": "How Github Copilot and ChatGPT have changed my life as an R developer",
    "section": "",
    "text": "The world of development is evolving rapidly, and artificial intelligence (AI) is playing an increasingly crucial role in developers‚Äô daily lives. With the rise of AI tools, R developers can now automate repetitive tasks, speed up their workflow, and even discover new methods for analysis and visualization.\nI‚Äôll focus on a specific AI tool that can significantly assist R developers: GitHub Copilot. Copilot offers a variety of features, from code generation to programming assistance, automatic documentation, and problem-solving.\nI‚Äôll also give a quick feedback about my usage of ChatGPT."
  },
  {
    "objectID": "posts/iaforr/index.html#github-copilot",
    "href": "posts/iaforr/index.html#github-copilot",
    "title": "How Github Copilot and ChatGPT have changed my life as an R developer",
    "section": "GitHub Copilot",
    "text": "GitHub Copilot\nGitHub Copilot is an AI tool that assists developers in their daily work by generating code and other code-related elements (such as documentation) based on context. Copilot can be used as an extension for VSCode. Since the release of version 2023.09.0, GitHub Copilot is also available in RStudio. Copilot can be used to generate R code, comments, unit tests, documentation, and more.\n\nWhat Are the Prerequisites for Using GitHub Copilot?\nTo use GitHub Copilot, you need a GitHub account and a Copilot license. This tool is paid (see pricing options), but students, teachers, and maintainers of popular open-source projects can get a free license.\n\n\nGitHub Copilot in RStudio\nTo use GitHub Copilot in RStudio, install the latest version of RStudio (2023.09.0 or later). Once installed, activate Copilot by going to Tools &gt; Global Options &gt; Copilot and checking the box Enable GitHub Copilot.\n\nIf you want Copilot to base its suggestions not only on the current file but also on other project files, check the box Index project files with GitHub Copilot.\n\n\nGitHub Copilot in VSCode\nTo use GitHub Copilot in VSCode, install the GitHub Copilot extension. Once the extension is installed, enable Copilot by logging into your GitHub account.\n\n\nGitHub Copilot in Positron\nCurrently, GitHub Copilot is not available in Positron."
  },
  {
    "objectID": "posts/iaforr/index.html#github-copilot-for-r-development",
    "href": "posts/iaforr/index.html#github-copilot-for-r-development",
    "title": "How Github Copilot and ChatGPT have changed my life as an R developer",
    "section": "GitHub Copilot for R Development",
    "text": "GitHub Copilot for R Development\nWe‚Äôll review GitHub Copilot‚Äôs features for R development. Some features are available in both RStudio and VSCode, while others can only be used in VSCode.\n\nCode Completion: Writing Functions\nLet‚Äôs say we‚Äôre developing an R package and want to write a function to clean text by removing spaces and special characters.\nWe start with a comment describing the function‚Äôs intent and provide an empty function skeleton:\n# Function to clean text by removing spaces and special characters\nclean_text &lt;- function(text) {  \n}\nAfter a few seconds, Copilot suggests an implementation for clean_text. Suggestions appear in gray and can be accepted by pressing the Tab key.\n\nThe initial function comment isn‚Äôt mandatory, but it helps Copilot better understand the context and suggest more relevant code.\nCode completion also works seamlessly in VSCode.\n\nInterestingly, in both cases, a step to convert text to lowercase is suggested, even though I didn‚Äôt request it. This could be useful, but make sure this step fits your use case. Remember, Copilot isn‚Äôt perfect and may sometimes generate incorrect or inappropriate code. Always review and modify the generated code as necessary.\nYou can continue in RStudio to generate the function‚Äôs documentation with Roxygen tags, for instance. Again, starting with a comment indicating your intention allows Copilot to suggest documentation.\n\nRStudio usage is limited to code completion, so we‚Äôll switch to VSCode to showcase more advanced features and a fuller development experience.\n\n\nHow to Access GitHub Copilot Features in VSCode?\nThere are multiple ways to access Copilot‚Äôs interface in VSCode. Right-clicking on an open file allows you to access the Copilot option in the context menu. You can also use the shortcut Ctrl + Shift + P (on Windows) to open the command palette, then type Copilot to access the interface. Recently, a Copilot icon was also added to the VSCode toolbar.\n\n\n\nChat\nCopilot can be used as a chatbot to get information on functions or packages, or to write code, as we did before.\n\n\nAgain, providing as much context as possible will lead to more relevant suggestions.\nYou can also use the chat to modify the code Copilot initially generated, for example, to change the packages used.\n\n\n\nCode Explanation\nCopilot can also explain code. For example, if you don‚Äôt understand some code, you can ask Copilot to explain it.\n \nNote: This feature is also accessible via chat by typing ‚Äú/explain‚Äù.\n\n\nCode Correction\nFollowing the same process, select the ‚ÄúFix‚Äù option to detect errors in the code. Here, Copilot didn‚Äôt detect an error but suggested an enhancement. Our code didn‚Äôt initially trim leading and trailing spaces. Copilot offers a solution to fix this.\n\nNote: This feature is also accessible via chat by typing ‚Äú/fix‚Äù.\n\n\nCode Review\nThe ‚ÄúReview and Comment‚Äù feature suggests improvements for style or performance.\n\n\n\nDocumentation\nThe ‚ÄúGenerate Doc‚Äù feature creates a Roxygen documentation skeleton for the function. The generated documentation is often generic, so you‚Äôll usually need to complete it, particularly for parameter explanations or reproducible examples. For instance, it may omit an @export tag, which could cause issues during a devtools::check() of your package!\n\nNote: This feature is also accessible via chat by typing ‚Äú/doc‚Äù.\n\n\nUnit Tests\nThe ‚ÄúGenerate Tests‚Äù option generates unit tests for the function. It works well but has the drawback of adding the test file in the package‚Äôs R/ folder. You‚Äôll need to move the content into a chosen file in the testthat/tests/ folder.\nNote: This feature is also accessible via chat by typing ‚Äú/tests‚Äù.\n\n\nWhat About {shiny}?\nThough we‚Äôve focused on R package development, Copilot can also be used to develop Shiny applications. For example, to generate a simple Shiny app, start with a comment describing the app, and let Copilot generate the code. This is very useful for quickly setting up a UI, but as always, you‚Äôll need to refine the code to meet specific needs.\n \nFor a Shiny development assistant, you can also check out ShinyAssistant.\n\n\nSummary of the R Developer Experience with GitHub Copilot\nGitHub Copilot is a powerful tool that can greatly accelerate R package development. It can generate code, documentation, unit tests, and more. However, remember that Copilot isn‚Äôt perfect and can sometimes produce incorrect or unsuitable code. It‚Äôs essential to review and adjust the generated code as needed. It‚Äôs equally important to revise generated documentation and tests for accuracy and relevance.\nTo ensure sufficient unit tests, it‚Äôs recommended to check package coverage using the {covr} package.\nMoreover, there‚Äôs no magic behind this tool‚ÄîGitHub Copilot bases its suggestions on the current file‚Äôs content and other project files. The more precise the context, the more relevant the suggestions will be. Taking extra care with function and parameter names makes suggestions as suitable as possible (this is true for development even without Copilot!)."
  },
  {
    "objectID": "posts/iaforr/index.html#how-can-i-use-chatgpt-as-an-r-developer",
    "href": "posts/iaforr/index.html#how-can-i-use-chatgpt-as-an-r-developer",
    "title": "How Github Copilot and ChatGPT have changed my life as an R developer",
    "section": "How can I use ChatGPT as an R developer?",
    "text": "How can I use ChatGPT as an R developer?\nI also often rely on ChatGPT for R-programming related tasks.\nMore often, I‚Äôll use ChatGPT in advance of a task, to compare its suggestions with the way I would have approached the problem. This allows me to see if I‚Äôve forgotten something, or if I couldn‚Äôt have done things differently.\nI‚Äôll also use his knowledge to give me information on a package I don‚Äôt know, or to give me examples of code. It‚Äôs a great complement to the official documentation.\nIn the same way, I‚Äôll ask him to explain errors I encounter, or concepts I don‚Äôt understand.\nFinally, as with Github Copilot, the key lies in the quality of the question asked. The more precise the question, the more relevant the answer.\nI often tend to start my queries with: ‚ÄúI‚Äôm an R developer and I prefer using tidyverse packages. I‚Äôd like to know what I can do to‚Ä¶‚Äù. Telling him if you‚Äôre a user of specific packages can help refine the suggestions.\nExplain how a conversational assistant can answer specific questions, help with debugging, generate code examples and provide detailed explanations of errors or package usage.\n\nDid you know that some R-specific GPT‚Äôs are available?\nI recently discovered that some R-specific GPT‚Äôs are available. They are trained on R-specific data and can provide more relevant answers to R-related questions. I haven‚Äôt had the opportunity to test them yet, but I‚Äôm looking forward to it.\nHere is the way to access them:\nYou should click on ‚ÄúExplore GPTs‚Äù in the ChatGPT interface, then type ‚ÄúR programming‚Äù in the search menu.\n\n\n\nAmong the many R-specific GPT‚Äôs available, I recommend using R Wizard, which seems to be the most popular among R developers."
  },
  {
    "objectID": "posts/iaforr/index.html#conclusion",
    "href": "posts/iaforr/index.html#conclusion",
    "title": "How Github Copilot and ChatGPT have changed my life as an R developer",
    "section": "Conclusion",
    "text": "Conclusion\nFor R programmers, GitHub Copilot and ChatGPT can complement each other effectively. Copilot shines for in-context code generation, while ChatGPT is ideal for answering questions, exploring R libraries, and understanding errors. By combining these tools, R developers can boost productivity, streamline repetitive coding tasks, and expand their knowledge‚Äîall while enhancing their coding efficiency and accuracy.\nThe main takeaway is that these tools are here to help you, not replace you. They can save you time and provide new insights, but they can‚Äôt replace your expertise and creativity. Always review the generated code, documentation, and tests to ensure they meet your project‚Äôs requirements. Have fun !"
  },
  {
    "objectID": "posts/iaforr/index.html#ressources",
    "href": "posts/iaforr/index.html#ressources",
    "title": "How Github Copilot and ChatGPT have changed my life as an R developer",
    "section": "Ressources",
    "text": "Ressources\n\nGithub Copilot documentation\nGithub Copilot in RStudio\nVSCode extension for Github Copilot\nR Wizard GPT"
  }
]